{"language":"Solidity","sources":{"src/SocialRecovery/SocialRecovery.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.25;\n\nimport { ERC7579ValidatorBase } from \"modulekit/Modules.sol\";\nimport { PackedUserOperation, IAccountExecute } from \"modulekit/external/ERC4337.sol\";\nimport { SentinelList4337Lib, SENTINEL } from \"sentinellist/SentinelList4337.sol\";\nimport { CheckSignatures } from \"checknsignatures/CheckNSignatures.sol\";\nimport { IERC7579Account } from \"modulekit/Accounts.sol\";\nimport {\n    ModeLib, CallType, ModeCode, CALLTYPE_SINGLE\n} from \"modulekit/accounts/common/lib/ModeLib.sol\";\nimport { ExecutionLib } from \"modulekit/accounts/erc7579/lib/ExecutionLib.sol\";\nimport { LibSort } from \"solady/utils/LibSort.sol\";\nimport { ECDSA } from \"solady/utils/ECDSA.sol\";\n\n/**\n * @title SocialRecovery\n * @dev Module that allows users to recover their account using a social recovery mechanism\n * @author Rhinestone\n */\ncontract SocialRecovery is ERC7579ValidatorBase {\n    using LibSort for *;\n    using SentinelList4337Lib for SentinelList4337Lib.SentinelList;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                            CONSTANTS & STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    event ModuleInitialized(address indexed account);\n    event ModuleUninitialized(address indexed account);\n    event GuardianAdded(address indexed account, address guardian);\n    event GuardianRemoved(address indexed account, address guardian);\n    event ThresholdSet(address indexed account, uint256 threshold);\n\n    error UnsupportedOperation();\n    error InvalidGuardian(address guardian);\n    error NotSortedAndUnique();\n    error MaxGuardiansReached();\n    error ThresholdNotSet();\n    error InvalidThreshold();\n    error CannotRemoveGuardian();\n\n    // maximum number of guardians per account\n    uint256 constant MAX_GUARDIANS = 32;\n\n    // account => guardians\n    SentinelList4337Lib.SentinelList guardians;\n    // account => threshold\n    mapping(address account => uint256) public threshold;\n    // account => guardianCount\n    mapping(address => uint256) public guardianCount;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONFIG\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /**\n     * Initializes the module with the threshold and guardians\n     * @dev data is encoded as follows: abi.encode(threshold, guardians)\n     *\n     * @param data encoded data containing the threshold and guardians\n     */\n    function onInstall(bytes calldata data) external override {\n        // get the threshold and guardians from the data\n        (uint256 _threshold, address[] memory _guardians) = abi.decode(data, (uint256, address[]));\n\n        // check that guardians are sorted and uniquified\n        if (!_guardians.isSortedAndUniquified()) {\n            revert NotSortedAndUnique();\n        }\n\n        // make sure the threshold is set\n        if (_threshold == 0) {\n            revert ThresholdNotSet();\n        }\n\n        // make sure the threshold is less than the number of guardians\n        uint256 guardiansLength = _guardians.length;\n        if (guardiansLength < _threshold) {\n            revert InvalidThreshold();\n        }\n\n        // cache the account address\n        address account = msg.sender;\n\n        // check if max guardians is reached\n        if (guardiansLength > MAX_GUARDIANS) {\n            revert MaxGuardiansReached();\n        }\n\n        // set guardian count\n        guardianCount[account] = guardiansLength;\n\n        // set threshold\n        threshold[account] = _threshold;\n\n        // initialize the guardian list\n        guardians.init(account);\n\n        // add guardians to the list\n        for (uint256 i = 0; i < guardiansLength; i++) {\n            address _guardian = _guardians[i];\n            if (_guardian == address(0)) {\n                revert InvalidGuardian(_guardian);\n            }\n            guardians.push(account, _guardian);\n        }\n\n        // emit the ModuleInitialized event\n        emit ModuleInitialized(account);\n    }\n\n    /**\n     * Handles the uninstallation of the module and clears the threshold and guardians\n     * @dev the data parameter is not used\n     */\n    function onUninstall(bytes calldata) external override {\n        // cache the account address\n        address account = msg.sender;\n\n        // clear the guardians\n        guardians.popAll(account);\n\n        // delete the threshold\n        threshold[account] = 0;\n\n        // delete the guardian count\n        guardianCount[account] = 0;\n\n        // emit the ModuleUninitialized event\n        emit ModuleUninitialized(account);\n    }\n\n    /**\n     * Checks if the module is initialized\n     *\n     * @param smartAccount address of the smart account\n     * @return true if the module is initialized, false otherwise\n     */\n    function isInitialized(address smartAccount) public view returns (bool) {\n        return threshold[smartAccount] != 0;\n    }\n\n    /**\n     * Sets the threshold for the account\n     * @dev the function will revert if the module is not initialized\n     *\n     * @param _threshold uint256 threshold to set\n     */\n    function setThreshold(uint256 _threshold) external {\n        // cache the account address\n        address account = msg.sender;\n        // check if the module is initialized and revert if it is not\n        if (!isInitialized(account)) revert NotInitialized(account);\n\n        // make sure the threshold is set\n        if (_threshold == 0) {\n            revert InvalidThreshold();\n        }\n\n        if (guardianCount[account] < _threshold) {\n            revert InvalidThreshold();\n        }\n\n        // set the threshold\n        threshold[account] = _threshold;\n\n        // emit the ThresholdSet event\n        emit ThresholdSet(account, _threshold);\n    }\n\n    /**\n     * Adds a guardian to the account\n     * @dev will revert if the guardian is already added\n     *\n     * @param guardian address of the guardian to add\n     */\n    function addGuardian(address guardian) external {\n        // cache the account address\n        address account = msg.sender;\n        // check if the module is initialized and revert if it is not\n        if (!isInitialized(account)) revert NotInitialized(account);\n\n        // revert if the guardian is address(0)\n        if (guardian == address(0)) {\n            revert InvalidGuardian(guardian);\n        }\n\n        // check if max guardians is reached\n        if (guardianCount[account] >= MAX_GUARDIANS) {\n            revert MaxGuardiansReached();\n        }\n\n        // increment the guardian count\n        guardianCount[account]++;\n\n        // add the guardian to the list\n        guardians.push(account, guardian);\n\n        // emit the GuardianAdded event\n        emit GuardianAdded(account, guardian);\n    }\n\n    /**\n     * Removes a guardian from the account\n     * @dev will revert if the guardian is not added or the previous guardian is invalid\n     *\n     * @param prevGuardian address of the previous guardian\n     * @param guardian address of the guardian to remove\n     */\n    function removeGuardian(address prevGuardian, address guardian) external {\n        // cache the account address\n        address account = msg.sender;\n\n        // check if an guardian can be removed\n        if (guardianCount[account] == threshold[account]) {\n            // if the guardian count is equal to the threshold, revert\n            // this means that removing an guardian would make the threshold unreachable\n            revert CannotRemoveGuardian();\n        }\n\n        // remove the guardian from the list\n        guardians.pop(account, prevGuardian, guardian);\n\n        // decrement the guardian count\n        guardianCount[account]--;\n\n        // emit the GuardianRemoved event\n        emit GuardianRemoved(account, guardian);\n    }\n\n    /**\n     * Gets the guardians for the account\n     *\n     * @param account address of the account\n     *\n     * @return guardiansArray array of guardians\n     */\n    function getGuardians(address account)\n        external\n        view\n        returns (address[] memory guardiansArray)\n    {\n        // get the guardians from the list\n        (guardiansArray,) = guardians.getEntriesPaginated(account, SENTINEL, MAX_GUARDIANS);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     MODULE LOGIC\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /**\n     * Validates a user operation\n     *\n     * @param userOp PackedUserOperation struct containing the UserOperation\n     * @param userOpHash bytes32 hash of the UserOperation\n     *\n     * @return ValidationData the UserOperation validation result\n     */\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash\n    )\n        external\n        view\n        override\n        returns (ValidationData)\n    {\n        // get the account\n        address account = userOp.sender;\n\n        // get the threshold and check that its set\n        uint256 _threshold = threshold[account];\n        if (_threshold == 0) {\n            return VALIDATION_FAILED;\n        }\n\n        // recover the signers from the signatures\n        address[] memory signers = CheckSignatures.recoverNSignatures(\n            ECDSA.toEthSignedMessageHash(userOpHash), userOp.signature, _threshold\n        );\n\n        // sort and uniquify the signers to make sure a signer is not reused\n        signers.sort();\n        signers.uniquifySorted();\n\n        // Check if the signers are guardians\n        uint256 validSigners;\n        for (uint256 i = 0; i < signers.length; i++) {\n            if (guardians.contains(account, signers[i])) {\n                validSigners++;\n            }\n        }\n\n        // check if the execution is allowed\n        bool isAllowedExecution;\n        bytes4 selector = bytes4(userOp.callData[0:4]);\n        if (selector == IERC7579Account.execute.selector) {\n            // decode and check the execution\n            // only single executions to installed validators are allowed\n            isAllowedExecution = _decodeAndCheckExecution(account, userOp.callData);\n        } else if (selector == IAccountExecute.executeUserOp.selector) {\n            if (bytes4(userOp.callData[4:8]) == IERC7579Account.execute.selector) {\n                // decode and check the execution\n                // only single executions to installed validators are allowed\n                isAllowedExecution = _decodeAndCheckExecution(account, userOp.callData[4:]);\n            }\n        }\n\n        // check if the threshold is met and the execution is allowed and return the result\n        if (validSigners >= _threshold && isAllowedExecution) {\n            return VALIDATION_SUCCESS;\n        }\n        return VALIDATION_FAILED;\n    }\n\n    /**\n     * Validates an ERC-1271 signature with the sender\n     * @dev ERC-1271 not supported for SocialRecovery\n     */\n    function isValidSignatureWithSender(\n        address,\n        bytes32,\n        bytes calldata\n    )\n        external\n        pure\n        override\n        returns (bytes4)\n    {\n        revert UnsupportedOperation();\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     INTERNAL\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /**\n     * Decodes and checks the execution\n     *\n     * @param account address of the account\n     * @param callData bytes calldata containing the call data\n     *\n     * @return isAllowedExecution true if the execution is allowed, false otherwise\n     */\n    function _decodeAndCheckExecution(\n        address account,\n        bytes calldata callData\n    )\n        internal\n        view\n        returns (bool isAllowedExecution)\n    {\n        // get the mode and call type\n        ModeCode mode = ModeCode.wrap(bytes32(callData[4:36]));\n        CallType calltype = ModeLib.getCallType(mode);\n\n        if (calltype == CALLTYPE_SINGLE) {\n            // decode the calldata\n            (address to,,) = ExecutionLib.decodeSingle(callData[100:]);\n\n            // check if the module is installed as a validator\n            return IERC7579Account(account).isModuleInstalled(TYPE_VALIDATOR, to, \"\");\n        } else {\n            return false;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     METADATA\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /**\n     * Returns the type of the module\n     *\n     * @param typeID type of the module\n     *\n     * @return true if the type is a module type, false otherwise\n     */\n    function isModuleType(uint256 typeID) external pure override returns (bool) {\n        return typeID == TYPE_VALIDATOR;\n    }\n\n    /**\n     * Returns the name of the module\n     *\n     * @return name of the module\n     */\n    function name() external pure virtual returns (string memory) {\n        return \"SocialRecoveryValidator\";\n    }\n\n    /**\n     * Returns the version of the module\n     *\n     * @return version of the module\n     */\n    function version() external pure virtual returns (string memory) {\n        return \"1.0.0\";\n    }\n}\n"},"node_modules/@rhinestone/modulekit/src/Modules.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.23 <0.9.0;\n\n/* solhint-disable no-unused-import */\n\n/*//////////////////////////////////////////////////////////////\n                          INTERFACES\n//////////////////////////////////////////////////////////////*/\n\nimport {\n    IValidator as IERC7579Validator,\n    IExecutor as IERC7579Executor,\n    IFallback as IERC7579Fallback,\n    IHook as IERC7579Hook,\n    IModule as IERC7579Module\n} from \"./accounts/common/interfaces/IERC7579Module.sol\";\n\n/*//////////////////////////////////////////////////////////////\n                            BASES\n//////////////////////////////////////////////////////////////*/\n\n// Core\nimport { ERC7579ModuleBase } from \"./module-bases/ERC7579ModuleBase.sol\";\n\n// Validators\nimport { ERC7579ValidatorBase } from \"./module-bases/ERC7579ValidatorBase.sol\";\nimport { ERC7579StatelessValidatorBase } from \"./module-bases/ERC7579StatelessValidatorBase.sol\";\nimport { ERC7579HybridValidatorBase } from \"./module-bases/ERC7579HybridValidatorBase.sol\";\n\n// Executors\nimport { ERC7579ExecutorBase } from \"./module-bases/ERC7579ExecutorBase.sol\";\n\n// Hooks\nimport { ERC7579HookBase } from \"./module-bases/ERC7579HookBase.sol\";\nimport { ERC7579HookDestruct } from \"./module-bases/ERC7579HookDestruct.sol\";\n\n// Fallbacks\nimport { ERC7579FallbackBase } from \"./module-bases/ERC7579FallbackBase.sol\";\n\n// Misc\nimport { SchedulingBase } from \"./module-bases/SchedulingBase.sol\";\nimport { ERC7484RegistryAdapter } from \"./module-bases/ERC7484RegistryAdapter.sol\";\n\n// Policies\nimport { ERC7579PolicyBase } from \"./module-bases/ERC7579PolicyBase.sol\";\nimport { ERC1271Policy } from \"./module-bases/ERC1271Policy.sol\";\nimport { ERC7579ActionPolicy } from \"./module-bases/ERC7579ActionPolicy.sol\";\nimport { ERC7579UserOpPolicy } from \"./module-bases/ERC7579UserOpPolicy.sol\";\n\n/*//////////////////////////////////////////////////////////////\n                            UTIL\n//////////////////////////////////////////////////////////////*/\n\nimport { TrustedForwarder } from \"./module-bases/utils/TrustedForwarder.sol\";\n"},"node_modules/@rhinestone/modulekit/src/external/ERC4337.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.23 <0.9.0;\n\n/* solhint-disable no-unused-import */\n\n/*//////////////////////////////////////////////////////////////\n                            USEROP\n//////////////////////////////////////////////////////////////*/\n\nimport { PackedUserOperation } from\n    \"@ERC4337/account-abstraction/contracts/interfaces/PackedUserOperation.sol\";\nimport { UserOperationLib } from \"@ERC4337/account-abstraction/contracts/core/UserOperationLib.sol\";\n\n/*//////////////////////////////////////////////////////////////\n                            ENTRYPOINT\n//////////////////////////////////////////////////////////////*/\n\nimport { EntryPointSimulations } from\n    \"@ERC4337/account-abstraction/contracts/core/EntryPointSimulations.sol\";\n\n/*//////////////////////////////////////////////////////////////\n                            VALIDATION\n//////////////////////////////////////////////////////////////*/\n\nimport {\n    ValidationData,\n    _packValidationData\n} from \"@ERC4337/account-abstraction/contracts/core/Helpers.sol\";\n\n/*//////////////////////////////////////////////////////////////\n                            INTERFACES\n//////////////////////////////////////////////////////////////*/\n\nimport { IStakeManager } from \"@ERC4337/account-abstraction/contracts/interfaces/IStakeManager.sol\";\nimport { IAccount as IERC4337 } from\n    \"@ERC4337/account-abstraction/contracts/interfaces/IAccount.sol\";\nimport { IAccountExecute } from\n    \"@ERC4337/account-abstraction/contracts/interfaces/IAccountExecute.sol\";\nimport { IEntryPoint } from \"@ERC4337/account-abstraction/contracts/interfaces/IEntryPoint.sol\";\nimport { IEntryPointSimulations } from\n    \"@ERC4337/account-abstraction/contracts/interfaces/IEntryPointSimulations.sol\";\n"},"node_modules/@rhinestone/sentinellist/src/SentinelList4337.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Sentinel address\naddress constant SENTINEL = address(0x1);\n// Zero address\naddress constant ZERO_ADDRESS = address(0x0);\n\n/**\n * @title SentinelListLib\n * @dev Library for managing a linked list of addresses that is compliant with the ERC-4337\n * validation rules\n * @author Rhinestone\n */\nlibrary SentinelList4337Lib {\n    // Struct to hold the linked list\n    // This linked list has the account address as the inner key so it is ERC-4337 compliant\n    struct SentinelList {\n        mapping(address key => mapping(address account => address entry)) entries;\n    }\n\n    error LinkedList_AlreadyInitialized();\n    error LinkedList_InvalidPage();\n    error LinkedList_InvalidEntry(address entry);\n    error LinkedList_EntryAlreadyInList(address entry);\n\n    /**\n     * Initialize the linked list\n     *\n     * @param self The linked list\n     * @param account The account to initialize the linked list for\n     */\n    function init(SentinelList storage self, address account) internal {\n        if (alreadyInitialized(self, account)) revert LinkedList_AlreadyInitialized();\n        self.entries[SENTINEL][account] = SENTINEL;\n    }\n\n    /**\n     * Check if the linked list is already initialized\n     *\n     * @param self The linked list\n     * @param account The account to check if the linked list is initialized for\n     *\n     * @return bool True if the linked list is already initialized\n     */\n    function alreadyInitialized(\n        SentinelList storage self,\n        address account\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return self.entries[SENTINEL][account] != ZERO_ADDRESS;\n    }\n\n    /**\n     * Get the next entry in the linked list\n     *\n     * @param self The linked list\n     * @param account The account to get the next entry for\n     * @param entry The current entry\n     *\n     * @return address The next entry\n     */\n    function getNext(\n        SentinelList storage self,\n        address account,\n        address entry\n    )\n        internal\n        view\n        returns (address)\n    {\n        if (entry == ZERO_ADDRESS) {\n            revert LinkedList_InvalidEntry(entry);\n        }\n        return self.entries[entry][account];\n    }\n\n    /**\n     * Push a new entry to the linked list\n     *\n     * @param self The linked list\n     * @param account The account to push the new entry for\n     * @param newEntry The new entry\n     */\n    function push(SentinelList storage self, address account, address newEntry) internal {\n        if (newEntry == ZERO_ADDRESS || newEntry == SENTINEL) {\n            revert LinkedList_InvalidEntry(newEntry);\n        }\n        if (self.entries[newEntry][account] != ZERO_ADDRESS) {\n            revert LinkedList_EntryAlreadyInList(newEntry);\n        }\n        self.entries[newEntry][account] = self.entries[SENTINEL][account];\n        self.entries[SENTINEL][account] = newEntry;\n    }\n\n    /**\n     * Safe push a new entry to the linked list\n     * @dev This ensures that the linked list is initialized and initializes it if it is not\n     *\n     * @param self The linked list\n     * @param account The account to push the new entry for\n     * @param newEntry The new entry\n     */\n    function safePush(SentinelList storage self, address account, address newEntry) internal {\n        if (!alreadyInitialized(self, account)) {\n            init({ self: self, account: account });\n        }\n        push({ self: self, account: account, newEntry: newEntry });\n    }\n\n    /**\n     * Pop an entry from the linked list\n     *\n     * @param self The linked list\n     * @param account The account to pop the entry for\n     * @param prevEntry The entry before the entry to pop\n     * @param popEntry The entry to pop\n     */\n    function pop(\n        SentinelList storage self,\n        address account,\n        address prevEntry,\n        address popEntry\n    )\n        internal\n    {\n        if (popEntry == ZERO_ADDRESS || popEntry == SENTINEL) {\n            revert LinkedList_InvalidEntry(prevEntry);\n        }\n        if (self.entries[prevEntry][account] != popEntry) {\n            revert LinkedList_InvalidEntry(popEntry);\n        }\n        self.entries[prevEntry][account] = self.entries[popEntry][account];\n        self.entries[popEntry][account] = ZERO_ADDRESS;\n    }\n\n    /**\n     * Pop all entries from the linked list\n     *\n     * @param self The linked list\n     * @param account The account to pop all entries for\n     */\n    function popAll(SentinelList storage self, address account) internal {\n        address next = self.entries[SENTINEL][account];\n        while (next != ZERO_ADDRESS) {\n            address current = next;\n            next = self.entries[next][account];\n            self.entries[current][account] = ZERO_ADDRESS;\n        }\n    }\n\n    /**\n     * Check if the linked list contains an entry\n     *\n     * @param self The linked list\n     * @param account The account to check if the entry is in the linked list for\n     * @param entry The entry to check for\n     *\n     * @return bool True if the linked list contains the entry\n     */\n    function contains(\n        SentinelList storage self,\n        address account,\n        address entry\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return SENTINEL != entry && self.entries[entry][account] != ZERO_ADDRESS;\n    }\n\n    /**\n     * Get all entries in the linked list\n     *\n     * @param self The linked list\n     * @param account The account to get the entries for\n     * @param start The start entry\n     * @param pageSize The page size\n     *\n     * @return array All entries in the linked list\n     * @return next The next entry\n     */\n    function getEntriesPaginated(\n        SentinelList storage self,\n        address account,\n        address start,\n        uint256 pageSize\n    )\n        internal\n        view\n        returns (address[] memory array, address next)\n    {\n        if (start != SENTINEL && !contains(self, account, start)) {\n            revert LinkedList_InvalidEntry(start);\n        }\n        if (pageSize == 0) revert LinkedList_InvalidPage();\n        // Init array with max page size\n        array = new address[](pageSize);\n\n        // Populate return array\n        uint256 entryCount = 0;\n        next = self.entries[start][account];\n        while (next != ZERO_ADDRESS && next != SENTINEL && entryCount < pageSize) {\n            array[entryCount] = next;\n            next = self.entries[next][account];\n            entryCount++;\n        }\n\n        /**\n         * Because of the argument validation, we can assume that the loop will always iterate over\n         * the valid entry list values\n         *       and the `next` variable will either be an enabled entry or a sentinel address\n         * (signalling the end).\n         *\n         *       If we haven't reached the end inside the loop, we need to set the next pointer to\n         * the last element of the entry array\n         *       because the `next` variable (which is a entry by itself) acting as a pointer to the\n         * start of the next page is neither\n         *       incSENTINELrent page, nor will it be included in the next one if you pass it as a\n         * start.\n         */\n        if (next != SENTINEL && entryCount > 0) {\n            next = array[entryCount - 1];\n        }\n        // Set correct size of returned array\n        // solhint-disable-next-line no-inline-assembly\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(array, entryCount)\n        }\n    }\n}\n"},"node_modules/@rhinestone/checknsignatures/src/CheckNSignatures.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport { ECDSA } from \"solady/utils/ECDSA.sol\";\n\n// EIP1271 magic value\nbytes4 constant EIP1271_MAGIC_VALUE = 0x1626ba7e;\n\nerror InvalidSignature();\nerror WrongContractSignatureFormat(uint256 s, uint256 contractSignatureLen, uint256 signaturesLen);\nerror WrongContractSignature(bytes contractSignature);\nerror WrongSignature(bytes signature);\n\n/**\n * @title CheckSignatures\n * @dev Library for recovering n signatures\n * @author Rhinestone\n * @notice This library is based on the Gnosis Safe signature recovery library\n */\nlibrary CheckSignatures {\n    /**\n     * Recover n signatures from a data hash\n     *\n     * @param dataHash The hash of the data\n     * @param signatures The concatenated signatures\n     * @param requiredSignatures The number of signatures required\n     *\n     * @return recoveredSigners The recovered signers\n     */\n    function recoverNSignatures(\n        bytes32 dataHash,\n        bytes memory signatures,\n        uint256 requiredSignatures\n    )\n        internal\n        view\n        returns (address[] memory recoveredSigners)\n    {\n        uint256 signaturesLength = signatures.length;\n        uint256 totalSignatures = signaturesLength / 65;\n        recoveredSigners = new address[](totalSignatures);\n        if (totalSignatures < requiredSignatures) revert InvalidSignature();\n        uint256 validSigCount;\n        for (uint256 i; i < totalSignatures; i++) {\n            // split v,r,s from signatures\n            address _signer;\n            (uint8 v, bytes32 r, bytes32 s) = signatureSplit({ signatures: signatures, pos: i });\n\n            if (v == 0) {\n                // If v is 0 then it is a contract signature\n                _signer = isValidContractSignature(dataHash, signatures, r, s, signaturesLength);\n            } else if (v > 30) {\n                // If v > 30 then default va (27,28) has been adjusted for eth_sign flow\n                // To support eth_sign and similar we adjust v and hash the messageHash with the\n                // Ethereum message prefix before applying ecrecover\n                _signer = ECDSA.tryRecover({\n                    hash: ECDSA.toEthSignedMessageHash(dataHash),\n                    v: v - 4,\n                    r: r,\n                    s: s\n                });\n            } else {\n                _signer = ECDSA.tryRecover({ hash: dataHash, v: v, r: r, s: s });\n            }\n            if (_signer != address(0)) {\n                validSigCount++;\n            }\n            recoveredSigners[i] = _signer;\n        }\n        if (validSigCount < requiredSignatures) revert InvalidSignature();\n    }\n\n    /**\n     * @notice Validates a contract signature following the ERC-1271 standard\n     * @param dataHash Hash of the data that has been signed\n     * @param signatures The concatenated signatures\n     * @param r Signature r value\n     * @param s Signature s value\n     * @param signaturesLength The length of the signatures\n     */\n    function isValidContractSignature(\n        bytes32 dataHash,\n        bytes memory signatures,\n        bytes32 r,\n        bytes32 s,\n        uint256 signaturesLength\n    )\n        internal\n        view\n        returns (address _signer)\n    {\n        // When handling contract signatures the address of the signer contract is encoded\n        // into r\n        _signer = address(uint160(uint256(r)));\n\n        // Check if the contract signature is in bounds: start of data is s + 32 and end is\n        // start + signature length\n        uint256 contractSignatureLen;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            contractSignatureLen := mload(add(add(signatures, s), 0x20))\n        }\n\n        // Check if the contract signature is in bounds\n        if (contractSignatureLen + uint256(s) + 32 > signaturesLength) {\n            return address(0);\n        }\n\n        // Check signature\n        bytes memory contractSignature;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // The signature data for contract signatures is appended to the concatenated\n            // signatures and the offset is stored in s\n            contractSignature := add(add(signatures, s), 0x20)\n        }\n        if (\n            ISignatureValidator(_signer).isValidSignature(dataHash, contractSignature)\n                != EIP1271_MAGIC_VALUE\n        ) return address(0);\n    }\n\n    /**\n     * @notice Splits signature bytes into `uint8 v, bytes32 r, bytes32 s`.\n     * @dev Make sure to perform a bounds check for @param pos, to avoid out of bounds access on\n     * @param signatures The signature format is a compact form of {bytes32 r}{bytes32 s}{uint8 v}\n     * Compact means uint8 is not padded to 32 bytes.\n     * @param pos Which signature to read. A prior bounds check of this parameter should be\n     * performed, to avoid out of bounds access.\n     * @param signatures Concatenated {r, s, v} signatures.\n     * @return v Recovery ID or Safe signature type.\n     * @return r Output value r of the signature.\n     * @return s Output value s of the signature.\n     *\n     * @ author Gnosis Team /rmeissner\n     */\n    function signatureSplit(\n        bytes memory signatures,\n        uint256 pos\n    )\n        internal\n        pure\n        returns (uint8 v, bytes32 r, bytes32 s)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        /// @solidity memory-safe-assembly\n        assembly {\n            let signaturePos := mul(0x41, pos)\n            r := mload(add(signatures, add(signaturePos, 0x20)))\n            s := mload(add(signatures, add(signaturePos, 0x40)))\n            v := byte(0, mload(add(signatures, add(signaturePos, 0x60))))\n        }\n    }\n}\n\nabstract contract ISignatureValidator {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param _dataHash Arbitrary length data signed on behalf of address(this)\n     * @param _signature Signature byte array associated with _data\n     *\n     * MUST return the bytes4 magic value when function passes.\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n     * MUST allow external calls\n     */\n    function isValidSignature(\n        bytes32 _dataHash,\n        bytes memory _signature\n    )\n        public\n        view\n        virtual\n        returns (bytes4);\n}\n"},"node_modules/@rhinestone/modulekit/src/Accounts.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.23 <0.9.0;\n\n/* solhint-disable no-unused-import */\n\n/*//////////////////////////////////////////////////////////////\n                            COMMON\n//////////////////////////////////////////////////////////////*/\n\nimport { IERC7579Account } from \"./accounts/common/interfaces/IERC7579Account.sol\";\n\n/*//////////////////////////////////////////////////////////////\n                        7579 REFERENCE\n//////////////////////////////////////////////////////////////*/\n\nimport { IMSA } from \"./accounts/erc7579/interfaces/IMSA.sol\";\n\n/*//////////////////////////////////////////////////////////////\n                            KERNEL\n//////////////////////////////////////////////////////////////*/\n\nimport { IERC7579Account as IKernelAccount } from \"./accounts/kernel/interfaces/IERC7579Account.sol\";\n\n/*//////////////////////////////////////////////////////////////\n                             SAFE\n//////////////////////////////////////////////////////////////*/\n\nimport { ISafe7579 } from \"./accounts/safe/interfaces/ISafe7579.sol\";\n"},"node_modules/@rhinestone/modulekit/src/accounts/common/lib/ModeLib.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.0 <0.9.0;\n\n/**\n * @title ModeLib\n * @author rhinestone | zeroknots.eth, Konrad Kopp (@kopy-kat)\n * To allow smart accounts to be very simple, but allow for more complex execution, A custom mode\n * encoding is used.\n *    Function Signature of execute function:\n *           function execute(ModeCode mode, bytes calldata executionCalldata) external payable;\n * This allows for a single bytes32 to be used to encode the execution mode, calltype, execType and\n * context.\n * NOTE: Simple Account implementations only have to scope for the most significant byte. Account  that\n * implement\n * more complex execution modes may use the entire bytes32.\n *\n * |--------------------------------------------------------------------|\n * | CALLTYPE  | EXECTYPE  |   UNUSED   | ModeSelector  |  ModePayload  |\n * |--------------------------------------------------------------------|\n * | 1 byte    | 1 byte    |   4 bytes  | 4 bytes       |   22 bytes    |\n * |--------------------------------------------------------------------|\n *\n * CALLTYPE: 1 byte\n * CallType is used to determine how the executeCalldata paramter of the execute function has to be\n * decoded.\n * It can be either single, batch or delegatecall. In the future different calls could be added.\n * CALLTYPE can be used by a validation module to determine how to decode <userOp.callData[36:]>.\n *\n * EXECTYPE: 1 byte\n * ExecType is used to determine how the account should handle the execution.\n * It can indicate if the execution should revert on failure or continue execution.\n * In the future more execution modes may be added.\n * Default Behavior (EXECTYPE = 0x00) is to revert on a single failed execution. If one execution in\n * a batch fails, the entire batch is reverted\n *\n * UNUSED: 4 bytes\n * Unused bytes are reserved for future use.\n *\n * ModeSelector: bytes4\n * The \"optional\" mode selector can be used by account vendors, to implement custom behavior in\n * their accounts.\n * the way a ModeSelector is to be calculated is bytes4(keccak256(\"vendorname.featurename\"))\n * this is to prevent collisions between different vendors, while allowing innovation and the\n * development of new features without coordination between ERC-7579 implementing accounts\n *\n * ModePayload: 22 bytes\n * Mode payload is used to pass additional data to the smart account execution, this may be\n * interpreted depending on the ModeSelector\n *\n * ExecutionCallData: n bytes\n * single, delegatecall or batch exec abi.encoded as bytes\n */\n\n// Custom type for improved developer experience\ntype ModeCode is bytes32;\n\ntype CallType is bytes1;\n\ntype ExecType is bytes1;\n\ntype ModeSelector is bytes4;\n\ntype ModePayload is bytes22;\n\n// Default CallType\nCallType constant CALLTYPE_SINGLE = CallType.wrap(0x00);\n// Batched CallType\nCallType constant CALLTYPE_BATCH = CallType.wrap(0x01);\nCallType constant CALLTYPE_STATIC = CallType.wrap(0xFE);\n// @dev Implementing delegatecall is OPTIONAL!\n// implement delegatecall with extreme care.\nCallType constant CALLTYPE_DELEGATECALL = CallType.wrap(0xFF);\n\n// @dev default behavior is to revert on failure\n// To allow very simple accounts to use mode encoding, the default behavior is to revert on failure\n// Since this is value 0x00, no additional encoding is required for simple accounts\nExecType constant EXECTYPE_DEFAULT = ExecType.wrap(0x00);\n// @dev account may elect to change execution behavior. For example \"try exec\" / \"allow fail\"\nExecType constant EXECTYPE_TRY = ExecType.wrap(0x01);\n\nModeSelector constant MODE_DEFAULT = ModeSelector.wrap(bytes4(0x00000000));\n// Example declaration of a custom mode selector\nModeSelector constant MODE_OFFSET = ModeSelector.wrap(bytes4(keccak256(\"default.mode.offset\")));\n\n/**\n * @dev ModeLib is a helper library to encode/decode ModeCodes\n */\nlibrary ModeLib {\n    function decode(ModeCode mode)\n        internal\n        pure\n        returns (\n            CallType _calltype,\n            ExecType _execType,\n            ModeSelector _modeSelector,\n            ModePayload _modePayload\n        )\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _calltype := mode\n            _execType := shl(8, mode)\n            _modeSelector := shl(48, mode)\n            _modePayload := shl(80, mode)\n        }\n    }\n\n    function encode(\n        CallType callType,\n        ExecType execType,\n        ModeSelector mode,\n        ModePayload payload\n    )\n        internal\n        pure\n        returns (ModeCode)\n    {\n        return ModeCode.wrap(\n            bytes32(\n                abi.encodePacked(callType, execType, bytes4(0), ModeSelector.unwrap(mode), payload)\n            )\n        );\n    }\n\n    function encodeSimpleBatch() internal pure returns (ModeCode mode) {\n        mode = encode(CALLTYPE_BATCH, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function encodeSimpleSingle() internal pure returns (ModeCode mode) {\n        mode = encode(CALLTYPE_SINGLE, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function getCallType(ModeCode mode) internal pure returns (CallType calltype) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            calltype := mode\n        }\n    }\n}\n\nusing { eqModeSelector as == } for ModeSelector global;\nusing { eqCallType as == } for CallType global;\nusing { neqCallType as != } for CallType global;\nusing { eqExecType as == } for ExecType global;\n\nfunction eqCallType(CallType a, CallType b) pure returns (bool) {\n    return CallType.unwrap(a) == CallType.unwrap(b);\n}\n\nfunction neqCallType(CallType a, CallType b) pure returns (bool) {\n    return CallType.unwrap(a) == CallType.unwrap(b);\n}\n\nfunction eqExecType(ExecType a, ExecType b) pure returns (bool) {\n    return ExecType.unwrap(a) == ExecType.unwrap(b);\n}\n\nfunction eqModeSelector(ModeSelector a, ModeSelector b) pure returns (bool) {\n    return ModeSelector.unwrap(a) == ModeSelector.unwrap(b);\n}\n"},"node_modules/@rhinestone/modulekit/src/accounts/erc7579/lib/ExecutionLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.23 <0.9.0;\n\n// Types\nimport { Execution } from \"../../common/interfaces/IERC7579Account.sol\";\n\n/**\n * Helper Library for decoding Execution calldata\n * malloc for memory allocation is bad for gas. use this assembly instead\n */\nlibrary ExecutionLib {\n    error ERC7579DecodingError();\n\n    /**\n     * @notice Decode a batch of `Execution` executionBatch from a `bytes` calldata.\n     * @dev code is copied from solady's LibERC7579.sol\n     * https://github.com/Vectorized/solady/blob/740812cedc9a1fc11e17cb3d4569744367dedf19/src/accounts/LibERC7579.sol#L146\n     *      Credits to Vectorized and the Solady Team\n     */\n    function decodeBatch(bytes calldata executionCalldata)\n        internal\n        pure\n        returns (Execution[] calldata executionBatch)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let u := calldataload(executionCalldata.offset)\n            let s := add(executionCalldata.offset, u)\n            let e := sub(add(executionCalldata.offset, executionCalldata.length), 0x20)\n            executionBatch.offset := add(s, 0x20)\n            executionBatch.length := calldataload(s)\n            if or(shr(64, u), gt(add(s, shl(5, executionBatch.length)), e)) {\n                mstore(0x00, 0xba597e7e) // `DecodingError()`.\n                revert(0x1c, 0x04)\n            }\n            if executionBatch.length {\n                // Perform bounds checks on the decoded `executionBatch`.\n                // Loop runs out-of-gas if `executionBatch.length` is big enough to cause overflows.\n                for { let i := executionBatch.length } 1 { } {\n                    i := sub(i, 1)\n                    let p := calldataload(add(executionBatch.offset, shl(5, i)))\n                    let c := add(executionBatch.offset, p)\n                    let q := calldataload(add(c, 0x40))\n                    let o := add(c, q)\n                    // forgefmt: disable-next-item\n                    if or(shr(64, or(calldataload(o), or(p, q))),\n                        or(gt(add(c, 0x40), e), gt(add(o, calldataload(o)), e))) {\n                        mstore(0x00, 0xba597e7e) // `DecodingError()`.\n                        revert(0x1c, 0x04)\n                    }\n                    if iszero(i) { break }\n                }\n            }\n        }\n    }\n\n    function encodeBatch(Execution[] memory executions)\n        internal\n        pure\n        returns (bytes memory callData)\n    {\n        callData = abi.encode(executions);\n    }\n\n    function decodeSingle(bytes calldata executionCalldata)\n        internal\n        pure\n        returns (address target, uint256 value, bytes calldata callData)\n    {\n        target = address(bytes20(executionCalldata[0:20]));\n        value = uint256(bytes32(executionCalldata[20:52]));\n        callData = executionCalldata[52:];\n    }\n\n    function encodeSingle(\n        address target,\n        uint256 value,\n        bytes memory callData\n    )\n        internal\n        pure\n        returns (bytes memory userOpCalldata)\n    {\n        userOpCalldata = abi.encodePacked(target, value, callData);\n    }\n}\n"},"node_modules/solady/src/utils/LibSort.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Optimized sorts and operations for sorted arrays.\n/// @author Solady (https://github.com/Vectorized/solady/blob/main/src/utils/LibSort.sol)\nlibrary LibSort {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      INSERTION SORT                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // - Faster on small arrays (32 or lesser elements).\n    // - Faster on almost sorted arrays.\n    // - Smaller bytecode (about 300 bytes smaller than sort, which uses intro-quicksort).\n    // - May be suitable for view functions intended for off-chain querying.\n\n    /// @dev Sorts the array in-place with insertion sort.\n    function insertionSort(uint256[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(a) // Length of `a`.\n            mstore(a, 0) // For insertion sort's inner loop to terminate.\n            let h := add(a, shl(5, n)) // High slot.\n            let w := not(0x1f)\n            for { let i := add(a, 0x20) } 1 {} {\n                i := add(i, 0x20)\n                if gt(i, h) { break }\n                let k := mload(i) // Key.\n                let j := add(i, w) // The slot before the current slot.\n                let v := mload(j) // The value of `j`.\n                if iszero(gt(v, k)) { continue }\n                for {} 1 {} {\n                    mstore(add(j, 0x20), v)\n                    j := add(j, w) // `sub(j, 0x20)`.\n                    v := mload(j)\n                    if iszero(gt(v, k)) { break }\n                }\n                mstore(add(j, 0x20), k)\n            }\n            mstore(a, n) // Restore the length of `a`.\n        }\n    }\n\n    /// @dev Sorts the array in-place with insertion sort.\n    function insertionSort(int256[] memory a) internal pure {\n        _flipSign(a);\n        insertionSort(_toUints(a));\n        _flipSign(a);\n    }\n\n    /// @dev Sorts the array in-place with insertion sort.\n    function insertionSort(address[] memory a) internal pure {\n        insertionSort(_toUints(a));\n    }\n\n    /// @dev Sorts the array in-place with insertion sort.\n    function insertionSort(bytes32[] memory a) internal pure {\n        insertionSort(_toUints(a));\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      INTRO-QUICKSORT                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // - Faster on larger arrays (more than 32 elements).\n    // - Robust performance.\n    // - Larger bytecode.\n\n    /// @dev Sorts the array in-place with intro-quicksort.\n    function sort(uint256[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function swap(a_, b_) -> _a, _b {\n                _b := a_\n                _a := b_\n            }\n            function mswap(i_, j_) {\n                let t_ := mload(i_)\n                mstore(i_, mload(j_))\n                mstore(j_, t_)\n            }\n            function sortInner(w_, l_, h_) {\n                // Do insertion sort if `h_ - l_ <= 0x20 * 12`.\n                // Threshold is fine-tuned via trial and error.\n                if iszero(gt(sub(h_, l_), 0x180)) {\n                    // Hardcode sort the first 2 elements.\n                    let i_ := add(l_, 0x20)\n                    if iszero(lt(mload(l_), mload(i_))) { mswap(i_, l_) }\n                    for {} 1 {} {\n                        i_ := add(i_, 0x20)\n                        if gt(i_, h_) { break }\n                        let k_ := mload(i_) // Key.\n                        let j_ := add(i_, w_) // The slot before the current slot.\n                        let v_ := mload(j_) // The value of `j_`.\n                        if iszero(gt(v_, k_)) { continue }\n                        for {} 1 {} {\n                            mstore(add(j_, 0x20), v_)\n                            j_ := add(j_, w_)\n                            v_ := mload(j_)\n                            if iszero(gt(v_, k_)) { break }\n                        }\n                        mstore(add(j_, 0x20), k_)\n                    }\n                    leave\n                }\n                // Pivot slot is the average of `l_` and `h_`.\n                let p_ := add(shl(5, shr(6, add(l_, h_))), and(31, l_))\n                // Median of 3 with sorting.\n                {\n                    let e0_ := mload(l_)\n                    let e1_ := mload(p_)\n                    if iszero(lt(e0_, e1_)) { e0_, e1_ := swap(e0_, e1_) }\n                    let e2_ := mload(h_)\n                    if iszero(lt(e1_, e2_)) {\n                        e1_, e2_ := swap(e1_, e2_)\n                        if iszero(lt(e0_, e1_)) { e0_, e1_ := swap(e0_, e1_) }\n                    }\n                    mstore(h_, e2_)\n                    mstore(p_, e1_)\n                    mstore(l_, e0_)\n                }\n                // Hoare's partition.\n                {\n                    // The value of the pivot slot.\n                    let x_ := mload(p_)\n                    p_ := h_\n                    for { let i_ := l_ } 1 {} {\n                        for {} 1 {} {\n                            i_ := add(0x20, i_)\n                            if iszero(gt(x_, mload(i_))) { break }\n                        }\n                        let j_ := p_\n                        for {} 1 {} {\n                            j_ := add(w_, j_)\n                            if iszero(lt(x_, mload(j_))) { break }\n                        }\n                        p_ := j_\n                        if iszero(lt(i_, p_)) { break }\n                        mswap(i_, p_)\n                    }\n                }\n                if iszero(eq(add(p_, 0x20), h_)) { sortInner(w_, add(p_, 0x20), h_) }\n                if iszero(eq(p_, l_)) { sortInner(w_, l_, p_) }\n            }\n\n            for { let n := mload(a) } iszero(lt(n, 2)) {} {\n                let w := not(0x1f) // `-0x20`.\n                let l := add(a, 0x20) // Low slot.\n                let h := add(a, shl(5, n)) // High slot.\n                let j := h\n                // While `mload(j - 0x20) <= mload(j): j -= 0x20`.\n                for {} iszero(gt(mload(add(w, j)), mload(j))) {} { j := add(w, j) }\n                // If the array is already sorted, break.\n                if iszero(gt(j, l)) { break }\n                // While `mload(j - 0x20) >= mload(j): j -= 0x20`.\n                for { j := h } iszero(lt(mload(add(w, j)), mload(j))) {} { j := add(w, j) }\n                // If the array is reversed sorted.\n                if iszero(gt(j, l)) {\n                    for {} 1 {} {\n                        let t := mload(l)\n                        mstore(l, mload(h))\n                        mstore(h, t)\n                        h := add(w, h)\n                        l := add(l, 0x20)\n                        if iszero(lt(l, h)) { break }\n                    }\n                    break\n                }\n                mstore(a, 0) // For insertion sort's inner loop to terminate.\n                sortInner(w, l, h)\n                mstore(a, n) // Restore the length of `a`.\n                break\n            }\n        }\n    }\n\n    /// @dev Sorts the array in-place with intro-quicksort.\n    function sort(int256[] memory a) internal pure {\n        _flipSign(a);\n        sort(_toUints(a));\n        _flipSign(a);\n    }\n\n    /// @dev Sorts the array in-place with intro-quicksort.\n    function sort(address[] memory a) internal pure {\n        sort(_toUints(a));\n    }\n\n    /// @dev Sorts the array in-place with intro-quicksort.\n    function sort(bytes32[] memory a) internal pure {\n        sort(_toUints(a));\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  OTHER USEFUL OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // For performance, the `uniquifySorted` methods will not revert if the\n    // array is not sorted -- it will simply remove consecutive duplicate elements.\n\n    /// @dev Removes duplicate elements from a ascendingly sorted memory array.\n    function uniquifySorted(uint256[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the length of `a` is greater than 1.\n            if iszero(lt(mload(a), 2)) {\n                let x := add(a, 0x20)\n                let y := add(a, 0x40)\n                let end := add(a, shl(5, add(mload(a), 1)))\n                for {} 1 {} {\n                    if iszero(eq(mload(x), mload(y))) {\n                        x := add(x, 0x20)\n                        mstore(x, mload(y))\n                    }\n                    y := add(y, 0x20)\n                    if eq(y, end) { break }\n                }\n                mstore(a, shr(5, sub(x, a)))\n            }\n        }\n    }\n\n    /// @dev Removes duplicate elements from a ascendingly sorted memory array.\n    function uniquifySorted(int256[] memory a) internal pure {\n        uniquifySorted(_toUints(a));\n    }\n\n    /// @dev Removes duplicate elements from a ascendingly sorted memory array.\n    function uniquifySorted(address[] memory a) internal pure {\n        uniquifySorted(_toUints(a));\n    }\n\n    /// @dev Removes duplicate elements from a ascendingly sorted memory array.\n    function uniquifySorted(bytes32[] memory a) internal pure {\n        uniquifySorted(_toUints(a));\n    }\n\n    /// @dev Returns whether `a` contains `needle`, and the index of `needle`.\n    /// `index` precedence: equal to > nearest before > nearest after.\n    function searchSorted(uint256[] memory a, uint256 needle)\n        internal\n        pure\n        returns (bool found, uint256 index)\n    {\n        (found, index) = _searchSorted(a, needle, 0);\n    }\n\n    /// @dev Returns whether `a` contains `needle`, and the index of `needle`.\n    /// `index` precedence: equal to > nearest before > nearest after.\n    function searchSorted(int256[] memory a, int256 needle)\n        internal\n        pure\n        returns (bool found, uint256 index)\n    {\n        (found, index) = _searchSorted(_toUints(a), uint256(needle), 1 << 255);\n    }\n\n    /// @dev Returns whether `a` contains `needle`, and the index of `needle`.\n    /// `index` precedence: equal to > nearest before > nearest after.\n    function searchSorted(address[] memory a, address needle)\n        internal\n        pure\n        returns (bool found, uint256 index)\n    {\n        (found, index) = _searchSorted(_toUints(a), uint160(needle), 0);\n    }\n\n    /// @dev Returns whether `a` contains `needle`, and the index of `needle`.\n    /// `index` precedence: equal to > nearest before > nearest after.\n    function searchSorted(bytes32[] memory a, bytes32 needle)\n        internal\n        pure\n        returns (bool found, uint256 index)\n    {\n        (found, index) = _searchSorted(_toUints(a), uint256(needle), 0);\n    }\n\n    /// @dev Returns whether `a` contains `needle`.\n    function inSorted(uint256[] memory a, uint256 needle) internal pure returns (bool found) {\n        (found,) = searchSorted(a, needle);\n    }\n\n    /// @dev Returns whether `a` contains `needle`.\n    function inSorted(int256[] memory a, int256 needle) internal pure returns (bool found) {\n        (found,) = searchSorted(a, needle);\n    }\n\n    /// @dev Returns whether `a` contains `needle`.\n    function inSorted(address[] memory a, address needle) internal pure returns (bool found) {\n        (found,) = searchSorted(a, needle);\n    }\n\n    /// @dev Returns whether `a` contains `needle`.\n    function inSorted(bytes32[] memory a, bytes32 needle) internal pure returns (bool found) {\n        (found,) = searchSorted(a, needle);\n    }\n\n    /// @dev Reverses the array in-place.\n    function reverse(uint256[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(mload(a), 2)) {\n                let s := 0x20\n                let w := not(0x1f)\n                let h := add(a, shl(5, mload(a)))\n                for { a := add(a, s) } 1 {} {\n                    let t := mload(a)\n                    mstore(a, mload(h))\n                    mstore(h, t)\n                    h := add(h, w)\n                    a := add(a, s)\n                    if iszero(lt(a, h)) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Reverses the array in-place.\n    function reverse(int256[] memory a) internal pure {\n        reverse(_toUints(a));\n    }\n\n    /// @dev Reverses the array in-place.\n    function reverse(address[] memory a) internal pure {\n        reverse(_toUints(a));\n    }\n\n    /// @dev Reverses the array in-place.\n    function reverse(bytes32[] memory a) internal pure {\n        reverse(_toUints(a));\n    }\n\n    /// @dev Returns a copy of the array.\n    function copy(uint256[] memory a) internal pure returns (uint256[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let end := add(add(result, 0x20), shl(5, mload(a)))\n            let o := result\n            for { let d := sub(a, result) } 1 {} {\n                mstore(o, mload(add(o, d)))\n                o := add(0x20, o)\n                if eq(o, end) { break }\n            }\n            mstore(0x40, o)\n        }\n    }\n\n    /// @dev Returns a copy of the array.\n    function copy(int256[] memory a) internal pure returns (int256[] memory result) {\n        result = _toInts(copy(_toUints(a)));\n    }\n\n    /// @dev Returns a copy of the array.\n    function copy(address[] memory a) internal pure returns (address[] memory result) {\n        result = _toAddresses(copy(_toUints(a)));\n    }\n\n    /// @dev Returns a copy of the array.\n    function copy(bytes32[] memory a) internal pure returns (bytes32[] memory result) {\n        result = _toBytes32s(copy(_toUints(a)));\n    }\n\n    /// @dev Returns whether the array is sorted in ascending order.\n    function isSorted(uint256[] memory a) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if iszero(lt(mload(a), 2)) {\n                let end := add(a, shl(5, mload(a)))\n                for { a := add(a, 0x20) } 1 {} {\n                    let p := mload(a)\n                    a := add(a, 0x20)\n                    result := iszero(gt(p, mload(a)))\n                    if iszero(mul(result, xor(a, end))) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns whether the array is sorted in ascending order.\n    function isSorted(int256[] memory a) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if iszero(lt(mload(a), 2)) {\n                let end := add(a, shl(5, mload(a)))\n                for { a := add(a, 0x20) } 1 {} {\n                    let p := mload(a)\n                    a := add(a, 0x20)\n                    result := iszero(sgt(p, mload(a)))\n                    if iszero(mul(result, xor(a, end))) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns whether the array is sorted in ascending order.\n    function isSorted(address[] memory a) internal pure returns (bool result) {\n        result = isSorted(_toUints(a));\n    }\n\n    /// @dev Returns whether the array is sorted in ascending order.\n    function isSorted(bytes32[] memory a) internal pure returns (bool result) {\n        result = isSorted(_toUints(a));\n    }\n\n    /// @dev Returns whether the array is strictly ascending (sorted and uniquified).\n    function isSortedAndUniquified(uint256[] memory a) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if iszero(lt(mload(a), 2)) {\n                let end := add(a, shl(5, mload(a)))\n                for { a := add(a, 0x20) } 1 {} {\n                    let p := mload(a)\n                    a := add(a, 0x20)\n                    result := lt(p, mload(a))\n                    if iszero(mul(result, xor(a, end))) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns whether the array is strictly ascending (sorted and uniquified).\n    function isSortedAndUniquified(int256[] memory a) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if iszero(lt(mload(a), 2)) {\n                let end := add(a, shl(5, mload(a)))\n                for { a := add(a, 0x20) } 1 {} {\n                    let p := mload(a)\n                    a := add(a, 0x20)\n                    result := slt(p, mload(a))\n                    if iszero(mul(result, xor(a, end))) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns whether the array is strictly ascending (sorted and uniquified).\n    function isSortedAndUniquified(address[] memory a) internal pure returns (bool result) {\n        result = isSortedAndUniquified(_toUints(a));\n    }\n\n    /// @dev Returns whether the array is strictly ascending (sorted and uniquified).\n    function isSortedAndUniquified(bytes32[] memory a) internal pure returns (bool result) {\n        result = isSortedAndUniquified(_toUints(a));\n    }\n\n    /// @dev Returns the sorted set difference of `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function difference(uint256[] memory a, uint256[] memory b)\n        internal\n        pure\n        returns (uint256[] memory c)\n    {\n        c = _difference(a, b, 0);\n    }\n\n    /// @dev Returns the sorted set difference between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function difference(int256[] memory a, int256[] memory b)\n        internal\n        pure\n        returns (int256[] memory c)\n    {\n        c = _toInts(_difference(_toUints(a), _toUints(b), 1 << 255));\n    }\n\n    /// @dev Returns the sorted set difference between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function difference(address[] memory a, address[] memory b)\n        internal\n        pure\n        returns (address[] memory c)\n    {\n        c = _toAddresses(_difference(_toUints(a), _toUints(b), 0));\n    }\n\n    /// @dev Returns the sorted set difference between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function difference(bytes32[] memory a, bytes32[] memory b)\n        internal\n        pure\n        returns (bytes32[] memory c)\n    {\n        c = _toBytes32s(_difference(_toUints(a), _toUints(b), 0));\n    }\n\n    /// @dev Returns the sorted set intersection between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function intersection(uint256[] memory a, uint256[] memory b)\n        internal\n        pure\n        returns (uint256[] memory c)\n    {\n        c = _intersection(a, b, 0);\n    }\n\n    /// @dev Returns the sorted set intersection between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function intersection(int256[] memory a, int256[] memory b)\n        internal\n        pure\n        returns (int256[] memory c)\n    {\n        c = _toInts(_intersection(_toUints(a), _toUints(b), 1 << 255));\n    }\n\n    /// @dev Returns the sorted set intersection between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function intersection(address[] memory a, address[] memory b)\n        internal\n        pure\n        returns (address[] memory c)\n    {\n        c = _toAddresses(_intersection(_toUints(a), _toUints(b), 0));\n    }\n\n    /// @dev Returns the sorted set intersection between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function intersection(bytes32[] memory a, bytes32[] memory b)\n        internal\n        pure\n        returns (bytes32[] memory c)\n    {\n        c = _toBytes32s(_intersection(_toUints(a), _toUints(b), 0));\n    }\n\n    /// @dev Returns the sorted set union of `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function union(uint256[] memory a, uint256[] memory b)\n        internal\n        pure\n        returns (uint256[] memory c)\n    {\n        c = _union(a, b, 0);\n    }\n\n    /// @dev Returns the sorted set union of `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function union(int256[] memory a, int256[] memory b)\n        internal\n        pure\n        returns (int256[] memory c)\n    {\n        c = _toInts(_union(_toUints(a), _toUints(b), 1 << 255));\n    }\n\n    /// @dev Returns the sorted set union between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function union(address[] memory a, address[] memory b)\n        internal\n        pure\n        returns (address[] memory c)\n    {\n        c = _toAddresses(_union(_toUints(a), _toUints(b), 0));\n    }\n\n    /// @dev Returns the sorted set union between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function union(bytes32[] memory a, bytes32[] memory b)\n        internal\n        pure\n        returns (bytes32[] memory c)\n    {\n        c = _toBytes32s(_union(_toUints(a), _toUints(b), 0));\n    }\n\n    /// @dev Cleans the upper 96 bits of the addresses.\n    /// In case `a` is produced via assembly and might have dirty upper bits.\n    function clean(address[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let addressMask := shr(96, not(0))\n            for { let end := add(a, shl(5, mload(a))) } iszero(eq(a, end)) {} {\n                a := add(a, 0x20)\n                mstore(a, and(mload(a), addressMask))\n            }\n        }\n    }\n\n    /// @dev Sorts and uniquifies `keys`. Updates `values` with the grouped sums by key.\n    function groupSum(uint256[] memory keys, uint256[] memory values) internal pure {\n        uint256 m;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m := mload(0x40) // Cache the free memory pointer, for freeing the memory.\n            if iszero(eq(mload(keys), mload(values))) {\n                mstore(0x00, 0x4e487b71)\n                mstore(0x20, 0x32) // Array out of bounds panic if the arrays lengths differ.\n                revert(0x1c, 0x24)\n            }\n        }\n        if (keys.length == uint256(0)) return;\n        (uint256[] memory oriKeys, uint256[] memory oriValues) = (copy(keys), copy(values));\n        insertionSort(keys); // Optimize for small `n` and bytecode size.\n        uniquifySorted(keys);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let d := sub(values, keys)\n            let w := not(0x1f)\n            let s := add(keys, 0x20) // Location of `keys[0]`.\n            mstore(values, mload(keys)) // Truncate.\n            calldatacopy(add(s, d), calldatasize(), shl(5, mload(keys))) // Zeroize.\n            for { let i := shl(5, mload(oriKeys)) } 1 {} {\n                let k := mload(add(oriKeys, i))\n                let v := mload(add(oriValues, i))\n                let j := s // Just do a linear scan to optimize for small `n` and bytecode size.\n                for {} iszero(eq(mload(j), k)) {} { j := add(j, 0x20) }\n                j := add(j, d) // Convert `j` to point into `values`.\n                mstore(j, add(mload(j), v))\n                if lt(mload(j), v) {\n                    mstore(0x00, 0x4e487b71)\n                    mstore(0x20, 0x11) // Overflow panic if the addition overflows.\n                    revert(0x1c, 0x24)\n                }\n                i := add(i, w) // `sub(i, 0x20)`.\n                if iszero(i) { break }\n            }\n            mstore(0x40, m) // Frees the memory allocated for the temporary copies.\n        }\n    }\n\n    /// @dev Sorts and uniquifies `keys`. Updates `values` with the grouped sums by key.\n    function groupSum(address[] memory keys, uint256[] memory values) internal pure {\n        groupSum(_toUints(keys), values);\n    }\n\n    /// @dev Sorts and uniquifies `keys`. Updates `values` with the grouped sums by key.\n    function groupSum(bytes32[] memory keys, uint256[] memory values) internal pure {\n        groupSum(_toUints(keys), values);\n    }\n\n    /// @dev Sorts and uniquifies `keys`. Updates `values` with the grouped sums by key.\n    function groupSum(int256[] memory keys, uint256[] memory values) internal pure {\n        groupSum(_toUints(keys), values);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Reinterpret cast to an uint256 array.\n    function _toUints(int256[] memory a) private pure returns (uint256[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted := a\n        }\n    }\n\n    /// @dev Reinterpret cast to an uint256 array.\n    function _toUints(address[] memory a) private pure returns (uint256[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // As any address written to memory will have the upper 96 bits\n            // of the word zeroized (as per Solidity spec), we can directly\n            // compare these addresses as if they are whole uint256 words.\n            casted := a\n        }\n    }\n\n    /// @dev Reinterpret cast to an uint256 array.\n    function _toUints(bytes32[] memory a) private pure returns (uint256[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted := a\n        }\n    }\n\n    /// @dev Reinterpret cast to an int array.\n    function _toInts(uint256[] memory a) private pure returns (int256[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted := a\n        }\n    }\n\n    /// @dev Reinterpret cast to an address array.\n    function _toAddresses(uint256[] memory a) private pure returns (address[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted := a\n        }\n    }\n\n    /// @dev Reinterpret cast to an bytes32 array.\n    function _toBytes32s(uint256[] memory a) private pure returns (bytes32[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted := a\n        }\n    }\n\n    /// @dev Converts an array of signed integers to unsigned\n    /// integers suitable for sorting or vice versa.\n    function _flipSign(int256[] memory a) private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := shl(255, 1)\n            for { let end := add(a, shl(5, mload(a))) } iszero(eq(a, end)) {} {\n                a := add(a, 0x20)\n                mstore(a, add(mload(a), w))\n            }\n        }\n    }\n\n    /// @dev Returns whether `a` contains `needle`, and the index of `needle`.\n    /// `index` precedence: equal to > nearest before > nearest after.\n    function _searchSorted(uint256[] memory a, uint256 needle, uint256 signed)\n        private\n        pure\n        returns (bool found, uint256 index)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0)\n            let l := 1\n            let h := mload(a)\n            let t := 0\n            for { needle := add(signed, needle) } 1 {} {\n                index := shr(1, add(l, h))\n                t := add(signed, mload(add(a, shl(5, index))))\n                if or(gt(l, h), eq(t, needle)) { break }\n                // Decide whether to search the left or right half.\n                if iszero(gt(needle, t)) {\n                    h := add(index, w)\n                    continue\n                }\n                l := add(index, 1)\n            }\n            // `index` will be zero in the case of an empty array,\n            // or when the value is less than the smallest value in the array.\n            found := eq(t, needle)\n            t := iszero(iszero(index))\n            index := mul(add(index, w), t)\n            found := and(found, t)\n        }\n    }\n\n    /// @dev Returns the sorted set difference of `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function _difference(uint256[] memory a, uint256[] memory b, uint256 signed)\n        private\n        pure\n        returns (uint256[] memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := 0x20\n            let aEnd := add(a, shl(5, mload(a)))\n            let bEnd := add(b, shl(5, mload(b)))\n            c := mload(0x40) // Set `c` to the free memory pointer.\n            a := add(a, s)\n            b := add(b, s)\n            let k := c\n            for {} iszero(or(gt(a, aEnd), gt(b, bEnd))) {} {\n                let u := mload(a)\n                let v := mload(b)\n                if iszero(xor(u, v)) {\n                    a := add(a, s)\n                    b := add(b, s)\n                    continue\n                }\n                if iszero(lt(add(u, signed), add(v, signed))) {\n                    b := add(b, s)\n                    continue\n                }\n                k := add(k, s)\n                mstore(k, u)\n                a := add(a, s)\n            }\n            for {} iszero(gt(a, aEnd)) {} {\n                k := add(k, s)\n                mstore(k, mload(a))\n                a := add(a, s)\n            }\n            mstore(c, shr(5, sub(k, c))) // Store the length of `c`.\n            mstore(0x40, add(k, s)) // Allocate the memory for `c`.\n        }\n    }\n\n    /// @dev Returns the sorted set intersection between `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function _intersection(uint256[] memory a, uint256[] memory b, uint256 signed)\n        private\n        pure\n        returns (uint256[] memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := 0x20\n            let aEnd := add(a, shl(5, mload(a)))\n            let bEnd := add(b, shl(5, mload(b)))\n            c := mload(0x40) // Set `c` to the free memory pointer.\n            a := add(a, s)\n            b := add(b, s)\n            let k := c\n            for {} iszero(or(gt(a, aEnd), gt(b, bEnd))) {} {\n                let u := mload(a)\n                let v := mload(b)\n                if iszero(xor(u, v)) {\n                    k := add(k, s)\n                    mstore(k, u)\n                    a := add(a, s)\n                    b := add(b, s)\n                    continue\n                }\n                if iszero(lt(add(u, signed), add(v, signed))) {\n                    b := add(b, s)\n                    continue\n                }\n                a := add(a, s)\n            }\n            mstore(c, shr(5, sub(k, c))) // Store the length of `c`.\n            mstore(0x40, add(k, s)) // Allocate the memory for `c`.\n        }\n    }\n\n    /// @dev Returns the sorted set union of `a` and `b`.\n    /// Note: Behaviour is undefined if inputs are not sorted and uniquified.\n    function _union(uint256[] memory a, uint256[] memory b, uint256 signed)\n        private\n        pure\n        returns (uint256[] memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := 0x20\n            let aEnd := add(a, shl(5, mload(a)))\n            let bEnd := add(b, shl(5, mload(b)))\n            c := mload(0x40) // Set `c` to the free memory pointer.\n            a := add(a, s)\n            b := add(b, s)\n            let k := c\n            for {} iszero(or(gt(a, aEnd), gt(b, bEnd))) {} {\n                let u := mload(a)\n                let v := mload(b)\n                if iszero(xor(u, v)) {\n                    k := add(k, s)\n                    mstore(k, u)\n                    a := add(a, s)\n                    b := add(b, s)\n                    continue\n                }\n                if iszero(lt(add(u, signed), add(v, signed))) {\n                    k := add(k, s)\n                    mstore(k, v)\n                    b := add(b, s)\n                    continue\n                }\n                k := add(k, s)\n                mstore(k, u)\n                a := add(a, s)\n            }\n            for {} iszero(gt(a, aEnd)) {} {\n                k := add(k, s)\n                mstore(k, mload(a))\n                a := add(a, s)\n            }\n            for {} iszero(gt(b, bEnd)) {} {\n                k := add(k, s)\n                mstore(k, mload(b))\n                b := add(b, s)\n            }\n            mstore(c, shr(5, sub(k, c))) // Store the length of `c`.\n            mstore(0x40, add(k, s)) // Allocate the memory for `c`.\n        }\n    }\n}\n"},"node_modules/solady/src/utils/ECDSA.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Gas optimized ECDSA wrapper.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ECDSA.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ECDSA.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol)\n///\n/// @dev Note:\n/// - The recovery functions use the ecrecover precompile (0x1).\n/// - As of Solady version 0.0.68, the `recover` variants will revert upon recovery failure.\n///   This is for more safety by default.\n///   Use the `tryRecover` variants if you need to get the zero address back\n///   upon recovery failure instead.\n/// - As of Solady version 0.0.134, all `bytes signature` variants accept both\n///   regular 65-byte `(r, s, v)` and EIP-2098 `(r, vs)` short form signatures.\n///   See: https://eips.ethereum.org/EIPS/eip-2098\n///   This is for calldata efficiency on smart accounts prevalent on L2s.\n///\n/// WARNING! Do NOT directly use signatures as unique identifiers:\n/// - The recovery operations do NOT check if a signature is non-malleable.\n/// - Use a nonce in the digest to prevent replay attacks on the same contract.\n/// - Use EIP-712 for the digest to prevent replay attacks across different chains and contracts.\n///   EIP-712 also enables readable signing of typed data for better user safety.\n/// - If you need a unique hash from a signature, please use the `canonicalHash` functions.\nlibrary ECDSA {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The order of the secp256k1 elliptic curve.\n    uint256 internal constant N = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141;\n\n    /// @dev `N/2 + 1`. Used for checking the malleability of the signature.\n    uint256 private constant _HALF_N_PLUS_1 =\n        0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The signature is invalid.\n    error InvalidSignature();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    RECOVERY OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\n    function recover(bytes32 hash, bytes memory signature) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let m := mload(0x40) } 1 {\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\n                revert(0x1c, 0x04)\n            } {\n                switch mload(signature)\n                case 64 {\n                    let vs := mload(add(signature, 0x40))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                }\n                case 65 {\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\n                }\n                default { continue }\n                mstore(0x00, hash)\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\n                result := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                if returndatasize() { break }\n            }\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\n    function recoverCalldata(bytes32 hash, bytes calldata signature)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let m := mload(0x40) } 1 {\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\n                revert(0x1c, 0x04)\n            } {\n                switch signature.length\n                case 64 {\n                    let vs := calldataload(add(signature.offset, 0x20))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                }\n                case 65 {\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\n                    calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\n                }\n                default { continue }\n                mstore(0x00, hash)\n                result := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                if returndatasize() { break }\n            }\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\n            mstore(0x40, r)\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\n            result := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            if iszero(returndatasize()) {\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the signature defined by `v`, `r`, `s`.\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            mstore(0x20, and(v, 0xff))\n            mstore(0x40, r)\n            mstore(0x60, s)\n            result := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            if iszero(returndatasize()) {\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   TRY-RECOVER OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // WARNING!\n    // These functions will NOT revert upon recovery failure.\n    // Instead, they will return the zero address upon recovery failure.\n    // It is critical that the returned address is NEVER compared against\n    // a zero address (e.g. an uninitialized address variable).\n\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\n    function tryRecover(bytes32 hash, bytes memory signature)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let m := mload(0x40) } 1 {} {\n                switch mload(signature)\n                case 64 {\n                    let vs := mload(add(signature, 0x40))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                }\n                case 65 {\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\n                }\n                default { break }\n                mstore(0x00, hash)\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\n                pop(staticcall(gas(), 1, 0x00, 0x80, 0x40, 0x20))\n                mstore(0x60, 0) // Restore the zero slot.\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                result := mload(xor(0x60, returndatasize()))\n                mstore(0x40, m) // Restore the free memory pointer.\n                break\n            }\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\n    function tryRecoverCalldata(bytes32 hash, bytes calldata signature)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let m := mload(0x40) } 1 {} {\n                switch signature.length\n                case 64 {\n                    let vs := calldataload(add(signature.offset, 0x20))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                }\n                case 65 {\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\n                    calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\n                }\n                default { break }\n                mstore(0x00, hash)\n                pop(staticcall(gas(), 1, 0x00, 0x80, 0x40, 0x20))\n                mstore(0x60, 0) // Restore the zero slot.\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                result := mload(xor(0x60, returndatasize()))\n                mstore(0x40, m) // Restore the free memory pointer.\n                break\n            }\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\n            mstore(0x40, r)\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\n            pop(staticcall(gas(), 1, 0x00, 0x80, 0x40, 0x20))\n            mstore(0x60, 0) // Restore the zero slot.\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            result := mload(xor(0x60, returndatasize()))\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the signature defined by `v`, `r`, `s`.\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            mstore(0x20, and(v, 0xff))\n            mstore(0x40, r)\n            mstore(0x60, s)\n            pop(staticcall(gas(), 1, 0x00, 0x80, 0x40, 0x20))\n            mstore(0x60, 0) // Restore the zero slot.\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            result := mload(xor(0x60, returndatasize()))\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     HASHING OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns an Ethereum Signed Message, created from a `hash`.\n    /// This produces a hash corresponding to the one signed with the\n    /// [`eth_sign`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sign)\n    /// JSON-RPC method as part of EIP-191.\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, hash) // Store into scratch space for keccak256.\n            mstore(0x00, \"\\x00\\x00\\x00\\x00\\x19Ethereum Signed Message:\\n32\") // 28 bytes.\n            result := keccak256(0x04, 0x3c) // `32 * 2 - (32 - 28) = 60 = 0x3c`.\n        }\n    }\n\n    /// @dev Returns an Ethereum Signed Message, created from `s`.\n    /// This produces a hash corresponding to the one signed with the\n    /// [`eth_sign`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sign)\n    /// JSON-RPC method as part of EIP-191.\n    /// Note: Supports lengths of `s` up to 999999 bytes.\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let sLength := mload(s)\n            let o := 0x20\n            mstore(o, \"\\x19Ethereum Signed Message:\\n\") // 26 bytes, zero-right-padded.\n            mstore(0x00, 0x00)\n            // Convert the `s.length` to ASCII decimal representation: `base10(s.length)`.\n            for { let temp := sLength } 1 {} {\n                o := sub(o, 1)\n                mstore8(o, add(48, mod(temp, 10)))\n                temp := div(temp, 10)\n                if iszero(temp) { break }\n            }\n            let n := sub(0x3a, o) // Header length: `26 + 32 - o`.\n            // Throw an out-of-offset error (consumes all gas) if the header exceeds 32 bytes.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0x20))\n            mstore(s, or(mload(0x00), mload(n))) // Temporarily store the header.\n            result := keccak256(add(s, sub(0x20, n)), add(n, sLength))\n            mstore(s, sLength) // Restore the length.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  CANONICAL HASH FUNCTIONS                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // The following functions return the hash of the signature in its canonicalized format,\n    // which is the 65-byte `abi.encodePacked(r, s, uint8(v))`, where `v` is either 27 or 28.\n    // If `s` is greater than `N / 2` then it will be converted to `N - s`\n    // and the `v` value will be flipped.\n    // If the signature has an invalid length, or if `v` is invalid,\n    // a uniquely corrupt hash will be returned.\n    // These functions are useful for \"poor-mans-VRF\".\n\n    /// @dev Returns the canonical hash of `signature`.\n    function canonicalHash(bytes memory signature) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := mload(signature)\n            for {} 1 {} {\n                mstore(0x00, mload(add(signature, 0x20))) // `r`.\n                let s := mload(add(signature, 0x40))\n                let v := mload(add(signature, 0x41))\n                if eq(l, 64) {\n                    v := add(shr(255, s), 27)\n                    s := shr(1, shl(1, s))\n                }\n                if iszero(lt(s, _HALF_N_PLUS_1)) {\n                    v := xor(v, 7)\n                    s := sub(N, s)\n                }\n                mstore(0x21, v)\n                mstore(0x20, s)\n                result := keccak256(0x00, 0x41)\n                mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n                break\n            }\n\n            // If the length is neither 64 nor 65, return a uniquely corrupted hash.\n            if iszero(lt(sub(l, 64), 2)) {\n                // `bytes4(keccak256(\"InvalidSignatureLength\"))`.\n                result := xor(keccak256(add(signature, 0x20), l), 0xd62f1ab2)\n            }\n        }\n    }\n\n    /// @dev Returns the canonical hash of `signature`.\n    function canonicalHashCalldata(bytes calldata signature)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                mstore(0x00, calldataload(signature.offset)) // `r`.\n                let s := calldataload(add(signature.offset, 0x20))\n                let v := calldataload(add(signature.offset, 0x21))\n                if eq(signature.length, 64) {\n                    v := add(shr(255, s), 27)\n                    s := shr(1, shl(1, s))\n                }\n                if iszero(lt(s, _HALF_N_PLUS_1)) {\n                    v := xor(v, 7)\n                    s := sub(N, s)\n                }\n                mstore(0x21, v)\n                mstore(0x20, s)\n                result := keccak256(0x00, 0x41)\n                mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n                break\n            }\n            // If the length is neither 64 nor 65, return a uniquely corrupted hash.\n            if iszero(lt(sub(signature.length, 64), 2)) {\n                calldatacopy(mload(0x40), signature.offset, signature.length)\n                // `bytes4(keccak256(\"InvalidSignatureLength\"))`.\n                result := xor(keccak256(mload(0x40), signature.length), 0xd62f1ab2)\n            }\n        }\n    }\n\n    /// @dev Returns the canonical hash of `signature`.\n    function canonicalHash(bytes32 r, bytes32 vs) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, r) // `r`.\n            let v := add(shr(255, vs), 27)\n            let s := shr(1, shl(1, vs))\n            mstore(0x21, v)\n            mstore(0x20, s)\n            result := keccak256(0x00, 0x41)\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the canonical hash of `signature`.\n    function canonicalHash(uint8 v, bytes32 r, bytes32 s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, r) // `r`.\n            if iszero(lt(s, _HALF_N_PLUS_1)) {\n                v := xor(v, 7)\n                s := sub(N, s)\n            }\n            mstore(0x21, v)\n            mstore(0x20, s)\n            result := keccak256(0x00, 0x41)\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   EMPTY CALLDATA HELPERS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns an empty calldata bytes.\n    function emptySignature() internal pure returns (bytes calldata signature) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            signature.length := 0\n        }\n    }\n}\n"},"node_modules/@rhinestone/modulekit/src/accounts/common/interfaces/IERC7579Module.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.23 <0.9.0;\n\n// Types\nimport { PackedUserOperation } from\n    \"@ERC4337/account-abstraction/contracts/core/UserOperationLib.sol\";\n\n// Constants\nuint256 constant VALIDATION_SUCCESS = 0;\nuint256 constant VALIDATION_FAILED = 1;\nuint256 constant MODULE_TYPE_VALIDATOR = 1;\nuint256 constant MODULE_TYPE_EXECUTOR = 2;\nuint256 constant MODULE_TYPE_FALLBACK = 3;\nuint256 constant MODULE_TYPE_HOOK = 4;\nuint256 constant MODULE_TYPE_PREVALIDATION_HOOK_ERC1271 = 8;\nuint256 constant MODULE_TYPE_PREVALIDATION_HOOK_ERC4337 = 9;\n\ninterface IModule {\n    error ModuleAlreadyInitialized(address smartAccount);\n    error NotInitialized(address smartAccount);\n\n    /**\n     * @dev This function is called by the smart account during installation of the module\n     * @param data arbitrary data that may be required on the module during `onInstall`\n     * initialization\n     *\n     * MUST revert on error (i.e. if module is already enabled)\n     */\n    function onInstall(bytes calldata data) external;\n\n    /**\n     * @dev This function is called by the smart account during uninstallation of the module\n     * @param data arbitrary data that may be required on the module during `onUninstall`\n     * de-initialization\n     *\n     * MUST revert on error\n     */\n    function onUninstall(bytes calldata data) external;\n\n    /**\n     * @dev Returns boolean value if module is a certain type\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     *\n     * MUST return true if the module is of the given type and false otherwise\n     */\n    function isModuleType(uint256 moduleTypeId) external view returns (bool);\n\n    /**\n     * @dev Returns if the module was already initialized for a provided smartaccount\n     */\n    function isInitialized(address smartAccount) external view returns (bool);\n}\n\ninterface IValidator is IModule {\n    error InvalidTargetAddress(address target);\n\n    /**\n     * @dev Validates a transaction on behalf of the account.\n     *         This function is intended to be called by the MSA during the ERC-4337 validaton phase\n     *         Note: solely relying on bytes32 hash and signature is not sufficient for some\n     * validation implementations (i.e. SessionKeys often need access to userOp.calldata)\n     * @param userOp The user operation to be validated. The userOp MUST NOT contain any metadata.\n     * The MSA MUST clean up the userOp before sending it to the validator.\n     * @param userOpHash The hash of the user operation to be validated\n     * @return return value according to ERC-4337\n     */\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash\n    )\n        external\n        payable\n        returns (uint256);\n\n    /**\n     * Validator can be used for ERC-1271 validation\n     */\n    function isValidSignatureWithSender(\n        address sender,\n        bytes32 hash,\n        bytes calldata data\n    )\n        external\n        view\n        returns (bytes4);\n}\n\ninterface IExecutor is IModule { }\n\ninterface IHook is IModule {\n    function preCheck(\n        address msgSender,\n        uint256 msgValue,\n        bytes calldata msgData\n    )\n        external\n        returns (bytes memory hookData);\n\n    function postCheck(bytes calldata hookData) external;\n}\n\ninterface IFallback is IModule { }\n\ninterface IPolicy is IModule {\n    function checkUserOpPolicy(\n        bytes32 id,\n        PackedUserOperation calldata userOp\n    )\n        external\n        payable\n        returns (uint256);\n    function checkSignaturePolicy(\n        bytes32 id,\n        address sender,\n        bytes32 hash,\n        bytes calldata sig\n    )\n        external\n        view\n        returns (uint256);\n}\n\ninterface ISigner is IModule {\n    function checkUserOpSignature(\n        bytes32 id,\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash\n    )\n        external\n        payable\n        returns (uint256);\n    function checkSignature(\n        bytes32 id,\n        address sender,\n        bytes32 hash,\n        bytes calldata sig\n    )\n        external\n        view\n        returns (bytes4);\n}\n\ninterface IPreValidationHookERC1271 is IModule {\n    function preValidationHookERC1271(\n        address sender,\n        bytes32 hash,\n        bytes calldata data\n    )\n        external\n        view\n        returns (bytes32 hookHash, bytes memory hookSignature);\n}\n\ninterface IPreValidationHookERC4337 is IModule {\n    function preValidationHookERC4337(\n        PackedUserOperation calldata userOp,\n        uint256 missingAccountFunds,\n        bytes32 userOpHash\n    )\n        external\n        returns (bytes32 hookHash, bytes memory hookSignature);\n}\n"},"node_modules/@rhinestone/modulekit/src/module-bases/ERC7579ModuleBase.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nimport { IModule as IERC7579Module } from \"../accounts/common/interfaces/IERC7579Module.sol\";\nimport {\n    MODULE_TYPE_VALIDATOR,\n    MODULE_TYPE_EXECUTOR,\n    MODULE_TYPE_FALLBACK,\n    MODULE_TYPE_HOOK,\n    MODULE_TYPE_POLICY,\n    MODULE_TYPE_SIGNER,\n    MODULE_TYPE_STATELESS_VALIDATOR\n} from \"./utils/ERC7579Constants.sol\";\n\nabstract contract ERC7579ModuleBase is IERC7579Module {\n    uint256 internal constant TYPE_VALIDATOR = MODULE_TYPE_VALIDATOR;\n    uint256 internal constant TYPE_EXECUTOR = MODULE_TYPE_EXECUTOR;\n    uint256 internal constant TYPE_FALLBACK = MODULE_TYPE_FALLBACK;\n    uint256 internal constant TYPE_HOOK = MODULE_TYPE_HOOK;\n    uint256 internal constant TYPE_POLICY = MODULE_TYPE_POLICY;\n    uint256 internal constant TYPE_SIGNER = MODULE_TYPE_SIGNER;\n    uint256 internal constant TYPE_STATELESS_VALIDATOR = MODULE_TYPE_STATELESS_VALIDATOR;\n}\n"},"node_modules/@rhinestone/modulekit/src/module-bases/ERC7579ValidatorBase.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nimport {\n    PackedUserOperation,\n    _packValidationData as _packValidationData4337\n} from \"../external/ERC4337.sol\";\nimport { ERC7579ModuleBase } from \"./ERC7579ModuleBase.sol\";\n\nabstract contract ERC7579ValidatorBase is ERC7579ModuleBase {\n    type ValidationData is uint256;\n\n    ValidationData internal constant VALIDATION_SUCCESS = ValidationData.wrap(0);\n    ValidationData internal constant VALIDATION_FAILED = ValidationData.wrap(1);\n    bytes4 internal constant EIP1271_SUCCESS = 0x1626ba7e;\n    bytes4 internal constant EIP1271_FAILED = 0xFFFFFFFF;\n\n    /**\n     * Helper to pack the return value for validateUserOp, when not using an aggregator.\n     * @param sigFailed  - True for signature failure, false for success.\n     * @param validUntil - Last timestamp this UserOperation is valid (or zero for\n     * infinite).\n     * @param validAfter - First timestamp this UserOperation is valid.\n     */\n    function _packValidationData(\n        bool sigFailed,\n        uint48 validUntil,\n        uint48 validAfter\n    )\n        internal\n        pure\n        returns (ValidationData)\n    {\n        return ValidationData.wrap(_packValidationData4337(sigFailed, validUntil, validAfter));\n    }\n\n    function _unpackValidationData(ValidationData _packedData)\n        internal\n        pure\n        returns (bool sigFailed, uint48 validUntil, uint48 validAfter)\n    {\n        uint256 packedData = ValidationData.unwrap(_packedData);\n        sigFailed = (packedData & 1) == 1;\n        validUntil = uint48((packedData >> 160) & ((1 << 48) - 1));\n        validAfter = uint48((packedData >> (160 + 48)) & ((1 << 48) - 1));\n    }\n\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash\n    )\n        external\n        virtual\n        returns (ValidationData);\n\n    function isValidSignatureWithSender(\n        address sender,\n        bytes32 hash,\n        bytes calldata data\n    )\n        external\n        view\n        virtual\n        returns (bytes4);\n}\n"},"node_modules/@rhinestone/modulekit/src/module-bases/ERC7579StatelessValidatorBase.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nimport { ERC7579ModuleBase } from \"./ERC7579ModuleBase.sol\";\nimport { IStatelessValidator } from \"./interfaces/IStatelessValidator.sol\";\n\nabstract contract ERC7579StatelessValidatorBase is ERC7579ModuleBase, IStatelessValidator {\n    function validateSignatureWithData(\n        bytes32,\n        bytes calldata,\n        bytes calldata\n    )\n        external\n        view\n        virtual\n        returns (bool validSig);\n}\n"},"node_modules/@rhinestone/modulekit/src/module-bases/ERC7579HybridValidatorBase.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\n/* solhint-disable no-unused-import */\n\nimport {\n    PackedUserOperation,\n    _packValidationData as _packValidationData4337\n} from \"../external/ERC4337.sol\";\nimport { ERC7579ValidatorBase } from \"./ERC7579ValidatorBase.sol\";\nimport { ERC7579StatelessValidatorBase } from \"./ERC7579StatelessValidatorBase.sol\";\n\n/// @notice Base contract for hybrid validators, which are both stateful and stateless.\nabstract contract ERC7579HybridValidatorBase is\n    ERC7579ValidatorBase,\n    ERC7579StatelessValidatorBase\n{ }\n"},"node_modules/@rhinestone/modulekit/src/module-bases/ERC7579ExecutorBase.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nimport { IExecutor as IERC7579Executor } from \"../accounts/common/interfaces/IERC7579Module.sol\";\nimport { IERC7579Account } from \"../accounts/common/interfaces/IERC7579Account.sol\";\nimport {\n    Execution,\n    ExecutionLib as ERC7579ExecutionLib\n} from \"../accounts/erc7579/lib/ExecutionLib.sol\";\nimport {\n    ModeCode,\n    ModeLib as ERC7579ModeLib,\n    CALLTYPE_SINGLE,\n    EXECTYPE_DEFAULT,\n    MODE_DEFAULT,\n    ModePayload,\n    CALLTYPE_BATCH,\n    EXECTYPE_DEFAULT,\n    MODE_DEFAULT,\n    CALLTYPE_DELEGATECALL\n} from \"../accounts/common/lib/ModeLib.sol\";\nimport { ERC7579ModuleBase } from \"./ERC7579ModuleBase.sol\";\n\nabstract contract ERC7579ExecutorBase is IERC7579Executor, ERC7579ModuleBase {\n    function _execute(\n        address account,\n        address to,\n        uint256 value,\n        bytes memory data\n    )\n        internal\n        returns (bytes memory result)\n    {\n        ModeCode modeCode = ERC7579ModeLib.encode({\n            callType: CALLTYPE_SINGLE,\n            execType: EXECTYPE_DEFAULT,\n            mode: MODE_DEFAULT,\n            payload: ModePayload.wrap(bytes22(0))\n        });\n\n        return IERC7579Account(account).executeFromExecutor(\n            modeCode, ERC7579ExecutionLib.encodeSingle(to, value, data)\n        )[0];\n    }\n\n    function _execute(\n        address to,\n        uint256 value,\n        bytes memory data\n    )\n        internal\n        returns (bytes memory result)\n    {\n        return _execute(msg.sender, to, value, data);\n    }\n\n    function _execute(\n        address account,\n        Execution[] memory execs\n    )\n        internal\n        returns (bytes[] memory results)\n    {\n        ModeCode modeCode = ERC7579ModeLib.encode({\n            callType: CALLTYPE_BATCH,\n            execType: EXECTYPE_DEFAULT,\n            mode: MODE_DEFAULT,\n            payload: ModePayload.wrap(bytes22(0))\n        });\n        results = IERC7579Account(account).executeFromExecutor(\n            modeCode, ERC7579ExecutionLib.encodeBatch(execs)\n        );\n    }\n\n    function _execute(Execution[] memory execs) internal returns (bytes[] memory results) {\n        return _execute(msg.sender, execs);\n    }\n\n    // Note: Not every account will support delegatecalls\n    function _executeDelegateCall(\n        address account,\n        address delegateTarget,\n        bytes memory callData\n    )\n        internal\n        returns (bytes[] memory results)\n    {\n        ModeCode modeCode = ERC7579ModeLib.encode({\n            callType: CALLTYPE_DELEGATECALL,\n            execType: EXECTYPE_DEFAULT,\n            mode: MODE_DEFAULT,\n            payload: ModePayload.wrap(bytes22(0))\n        });\n        results = IERC7579Account(account).executeFromExecutor(\n            modeCode, abi.encodePacked(delegateTarget, callData)\n        );\n    }\n\n    // Note: Not every account will support delegatecalls\n    function _executeDelegateCall(\n        address delegateTarget,\n        bytes memory callData\n    )\n        internal\n        returns (bytes[] memory results)\n    {\n        return _executeDelegateCall(msg.sender, delegateTarget, callData);\n    }\n}\n"},"node_modules/@rhinestone/modulekit/src/module-bases/ERC7579HookBase.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nimport { IHook as IERC7579Hook } from \"../accounts/common/interfaces/IERC7579Module.sol\";\nimport { ERC7579ModuleBase } from \"./ERC7579ModuleBase.sol\";\nimport { TrustedForwarder } from \"./utils/TrustedForwarder.sol\";\n\nabstract contract ERC7579HookBase is IERC7579Hook, ERC7579ModuleBase, TrustedForwarder {\n    /**\n     * Precheck hook\n     *\n     * @param msgSender sender of the transaction\n     * @param msgValue value of the transaction\n     * @param msgData data of the transaction\n     *\n     * @return hookData data for the postcheck hook\n     */\n    function preCheck(\n        address msgSender,\n        uint256 msgValue,\n        bytes calldata msgData\n    )\n        external\n        virtual\n        returns (bytes memory hookData)\n    {\n        // route to internal function\n        return _preCheck(_getAccount(), msgSender, msgValue, msgData);\n    }\n\n    /**\n     * Postcheck hook\n     *\n     * @param hookData data from the precheck hook\n     */\n    function postCheck(bytes calldata hookData) external virtual {\n        // route to internal function\n        _postCheck(_getAccount(), hookData);\n    }\n\n    /**\n     * Precheck hook\n     *\n     * @param account account of the transaction\n     * @param msgSender sender of the transaction\n     * @param msgValue value of the transaction\n     * @param msgData data of the transaction\n     *\n     * @return hookData data for the postcheck hook\n     */\n    function _preCheck(\n        address account,\n        address msgSender,\n        uint256 msgValue,\n        bytes calldata msgData\n    )\n        internal\n        virtual\n        returns (bytes memory hookData);\n\n    /**\n     * Postcheck hook\n     *\n     * @param account account of the transaction\n     * @param hookData data from the precheck hook\n     */\n    function _postCheck(address account, bytes calldata hookData) internal virtual;\n}\n"},"node_modules/@rhinestone/modulekit/src/module-bases/ERC7579HookDestruct.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nimport { IERC7579Account } from \"../accounts/common/interfaces/IERC7579Account.sol\";\nimport { IHook as IERC7579Hook } from \"../accounts/common/interfaces/IERC7579Module.sol\";\nimport { ExecutionLib, Execution } from \"../accounts/erc7579/lib/ExecutionLib.sol\";\nimport {\n    ModeLib,\n    CallType,\n    ModeCode,\n    CALLTYPE_SINGLE,\n    CALLTYPE_BATCH,\n    CALLTYPE_DELEGATECALL\n} from \"../accounts/common/lib/ModeLib.sol\";\nimport { IAccountExecute } from \"../external/ERC4337.sol\";\nimport { ERC7579ModuleBase } from \"./ERC7579ModuleBase.sol\";\nimport { TrustedForwarder } from \"./utils/TrustedForwarder.sol\";\n\nuint256 constant EXECUSEROP_OFFSET = 164;\nuint256 constant EXEC_OFFSET = 100;\nuint256 constant INSTALL_OFFSET = 132;\n\nabstract contract ERC7579HookDestruct is IERC7579Hook, ERC7579ModuleBase, TrustedForwarder {\n    error HookInvalidSelector();\n    error InvalidCallType();\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                CALLDATA DECODING\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function preCheck(\n        address msgSender,\n        uint256 msgValue,\n        bytes calldata msgData\n    )\n        external\n        virtual\n        override\n        returns (bytes memory hookData)\n    {\n        bytes4 selector = bytes4(msgData[0:4]);\n\n        if (selector == IAccountExecute.executeUserOp.selector) {\n            uint256 offset =\n                uint256(bytes32(msgData[EXECUSEROP_OFFSET:EXECUSEROP_OFFSET + 32])) + 68;\n            uint256 paramLen = uint256(bytes32(msgData[offset:offset + 32]));\n            offset += 32;\n            bytes calldata _msgData = msgData[offset:offset + paramLen];\n            return _decodeCallData(msgSender, msgValue, _msgData);\n        } else {\n            return _decodeCallData(msgSender, msgValue, msgData);\n        }\n    }\n\n    function _decodeCallData(\n        address msgSender,\n        uint256 msgValue,\n        bytes calldata msgData\n    )\n        internal\n        returns (bytes memory hookData)\n    {\n        bytes4 selector = bytes4(msgData[0:4]);\n        if (selector == IERC7579Account.execute.selector) {\n            return _handle4337Executions(msgSender, msgData);\n        } else if (selector == IERC7579Account.executeFromExecutor.selector) {\n            return _handleExecutorExecutions(msgSender, msgData);\n        } else if (selector == IERC7579Account.installModule.selector) {\n            uint256 paramLen = msgData.length > INSTALL_OFFSET\n                ? uint256(bytes32(msgData[INSTALL_OFFSET - 32:INSTALL_OFFSET]))\n                : uint256(0);\n            bytes calldata initData = msgData.length > INSTALL_OFFSET\n                ? msgData[INSTALL_OFFSET:INSTALL_OFFSET + paramLen]\n                : msgData[0:0];\n            uint256 moduleType = uint256(bytes32(msgData[4:36]));\n            address module = address(bytes20((msgData[48:68])));\n            return onInstallModule(_getAccount(), msgSender, moduleType, module, initData);\n        } else if (selector == IERC7579Account.uninstallModule.selector) {\n            uint256 paramLen = msgData.length > INSTALL_OFFSET\n                ? uint256(bytes32(msgData[INSTALL_OFFSET - 32:INSTALL_OFFSET]))\n                : uint256(0);\n            bytes calldata initData = msgData.length > INSTALL_OFFSET\n                ? msgData[INSTALL_OFFSET:INSTALL_OFFSET + paramLen]\n                : msgData[0:0];\n\n            uint256 moduleType = uint256(bytes32(msgData[4:36]));\n            address module = address(bytes20((msgData[48:68])));\n\n            return onUninstallModule(_getAccount(), msgSender, moduleType, module, initData);\n        } else {\n            return onUnknownFunction(_getAccount(), msgSender, msgValue, msgData);\n        }\n    }\n\n    function _handle4337Executions(\n        address msgSender,\n        bytes calldata msgData\n    )\n        internal\n        returns (bytes memory hookData)\n    {\n        uint256 paramLen = uint256(bytes32(msgData[EXEC_OFFSET - 32:EXEC_OFFSET]));\n        bytes calldata encodedExecutions = msgData[EXEC_OFFSET:EXEC_OFFSET + paramLen];\n\n        ModeCode mode = ModeCode.wrap(bytes32(msgData[4:36]));\n        CallType calltype = ModeLib.getCallType(mode);\n\n        if (calltype == CALLTYPE_SINGLE) {\n            (address to, uint256 value, bytes calldata callData) =\n                ExecutionLib.decodeSingle(encodedExecutions);\n            return onExecute(_getAccount(), msgSender, to, value, callData);\n        } else if (calltype == CALLTYPE_BATCH) {\n            Execution[] calldata execs = ExecutionLib.decodeBatch(encodedExecutions);\n            return onExecuteBatch(_getAccount(), msgSender, execs);\n        } else if (calltype == CALLTYPE_DELEGATECALL) {\n            address to = address(bytes20(encodedExecutions[0:20]));\n            bytes calldata callData = encodedExecutions[20:];\n            return onExecuteDelegateCall(_getAccount(), msgSender, to, callData);\n        } else {\n            revert InvalidCallType();\n        }\n    }\n\n    function _handleExecutorExecutions(\n        address msgSender,\n        bytes calldata msgData\n    )\n        internal\n        returns (bytes memory hookData)\n    {\n        uint256 paramLen = uint256(bytes32(msgData[EXEC_OFFSET - 32:EXEC_OFFSET]));\n        bytes calldata encodedExecutions = msgData[EXEC_OFFSET:EXEC_OFFSET + paramLen];\n\n        ModeCode mode = ModeCode.wrap(bytes32(msgData[4:36]));\n        CallType calltype = ModeLib.getCallType(mode);\n\n        if (calltype == CALLTYPE_SINGLE) {\n            (address to, uint256 value, bytes calldata callData) =\n                ExecutionLib.decodeSingle(encodedExecutions);\n            return onExecuteFromExecutor(_getAccount(), msgSender, to, value, callData);\n        } else if (calltype == CALLTYPE_BATCH) {\n            Execution[] calldata execs = ExecutionLib.decodeBatch(encodedExecutions);\n            return onExecuteBatchFromExecutor(_getAccount(), msgSender, execs);\n        } else if (calltype == CALLTYPE_DELEGATECALL) {\n            address to = address(bytes20(encodedExecutions[0:20]));\n            bytes calldata callData = encodedExecutions[20:];\n            return onExecuteDelegateCallFromExecutor(_getAccount(), msgSender, to, callData);\n        } else {\n            revert InvalidCallType();\n        }\n    }\n\n    function postCheck(bytes calldata hookData) external virtual override {\n        onPostCheck(_getAccount(), hookData);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     EXECUTION\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function onExecute(\n        address account,\n        address msgSender,\n        address target,\n        uint256 value,\n        bytes calldata callData\n    )\n        internal\n        virtual\n        returns (bytes memory hookData)\n    { }\n\n    function onExecuteBatch(\n        address account,\n        address msgSender,\n        Execution[] calldata\n    )\n        internal\n        virtual\n        returns (bytes memory hookData)\n    { }\n\n    function onExecuteDelegateCall(\n        address account,\n        address msgSender,\n        address target,\n        bytes calldata callData\n    )\n        internal\n        virtual\n        returns (bytes memory hookData)\n    { }\n\n    function onExecuteFromExecutor(\n        address account,\n        address msgSender,\n        address target,\n        uint256 value,\n        bytes calldata callData\n    )\n        internal\n        virtual\n        returns (bytes memory hookData)\n    { }\n\n    function onExecuteBatchFromExecutor(\n        address account,\n        address msgSender,\n        Execution[] calldata\n    )\n        internal\n        virtual\n        returns (bytes memory hookData)\n    { }\n\n    function onExecuteDelegateCallFromExecutor(\n        address account,\n        address msgSender,\n        address target,\n        bytes calldata callData\n    )\n        internal\n        virtual\n        returns (bytes memory hookData)\n    { }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONFIG\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function onInstallModule(\n        address account,\n        address msgSender,\n        uint256 moduleType,\n        address module,\n        bytes calldata initData\n    )\n        internal\n        virtual\n        returns (bytes memory hookData)\n    { }\n\n    function onUninstallModule(\n        address account,\n        address msgSender,\n        uint256 moduleType,\n        address module,\n        bytes calldata deInitData\n    )\n        internal\n        virtual\n        returns (bytes memory hookData)\n    { }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                UNKNOWN FUNCTION\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function onUnknownFunction(\n        address account,\n        address msgSender,\n        uint256 msgValue,\n        bytes calldata msgData\n    )\n        internal\n        virtual\n        returns (bytes memory hookData)\n    { }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     POSTCHECK\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function onPostCheck(address account, bytes calldata hookData) internal virtual { }\n}\n"},"node_modules/@rhinestone/modulekit/src/module-bases/ERC7579FallbackBase.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nimport { IFallback as IERC7579Fallback } from \"../accounts/common/interfaces/IERC7579Module.sol\";\nimport { ERC7579ModuleBase } from \"./ERC7579ModuleBase.sol\";\n\nabstract contract ERC7579FallbackBase is IERC7579Fallback, ERC7579ModuleBase {\n    /**\n     * @notice Allows fetching the original caller address.\n     * @dev This is only reliable in combination with a FallbackManager that supports this (e.g. Safe\n     * contract >=1.3.0).\n     *      When using this functionality make sure that the linked _manager (aka msg.sender)\n     * supports this.\n     *      This function does not rely on a trusted forwarder. Use the returned value only to\n     *      check information against the calling manager.\n     * @return sender Original caller address.\n     */\n    function _msgSender() internal pure returns (address sender) {\n        // The assembly code is more direct than the Solidity version using `abi.decode`.\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            sender := shr(96, calldataload(sub(calldatasize(), 20)))\n        }\n        /* solhint-enable no-inline-assembly */\n    }\n}\n"},"node_modules/@rhinestone/modulekit/src/module-bases/SchedulingBase.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nimport { ERC7579ExecutorBase } from \"./ERC7579ExecutorBase.sol\";\n\nabstract contract SchedulingBase is ERC7579ExecutorBase {\n    /*//////////////////////////////////////////////////////////////////////////\n                            CONSTANTS & STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    error InvalidExecution();\n\n    event ExecutionAdded(address indexed smartAccount, uint256 indexed jobId);\n    event ExecutionTriggered(address indexed smartAccount, uint256 indexed jobId);\n    event ExecutionStatusUpdated(address indexed smartAccount, uint256 indexed jobId);\n    event ExecutionsCancelled(address indexed smartAccount);\n\n    mapping(address smartAccount => mapping(uint256 jobId => ExecutionConfig)) public executionLog;\n\n    mapping(address smartAccount => uint256 jobCount) public accountJobCount;\n\n    struct ExecutionConfig {\n        uint48 executeInterval;\n        uint16 numberOfExecutions;\n        uint16 numberOfExecutionsCompleted;\n        uint48 startDate;\n        bool isEnabled;\n        uint48 lastExecutionTime;\n        bytes executionData;\n    }\n\n    struct ExecutorAccess {\n        uint256 jobId;\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONFIG\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function _onInstall(bytes calldata packedSchedulingData) internal {\n        address account = msg.sender;\n        if (isInitialized(account)) {\n            revert ModuleAlreadyInitialized(account);\n        }\n\n        _createExecution({ orderData: packedSchedulingData });\n    }\n\n    function _onUninstall() internal {\n        address account = msg.sender;\n\n        uint256 count = accountJobCount[account];\n        for (uint256 i = 1; i <= count; i++) {\n            delete executionLog[account][i];\n        }\n        accountJobCount[account] = 0;\n\n        emit ExecutionsCancelled(account);\n    }\n\n    function isInitialized(address smartAccount) public view returns (bool) {\n        return accountJobCount[smartAccount] != 0;\n    }\n\n    function addOrder(bytes calldata orderData) external {\n        address account = msg.sender;\n        if (!isInitialized(account)) revert NotInitialized(account);\n\n        _createExecution({ orderData: orderData });\n    }\n\n    function toggleOrder(uint256 jobId) external {\n        address account = msg.sender;\n\n        ExecutionConfig storage executionConfig = executionLog[account][jobId];\n\n        if (executionConfig.numberOfExecutions == 0) {\n            revert InvalidExecution();\n        }\n\n        executionConfig.isEnabled = !executionConfig.isEnabled;\n\n        emit ExecutionStatusUpdated(account, jobId);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     INTERNAL\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function _createExecution(bytes calldata orderData) internal {\n        address account = msg.sender;\n\n        uint256 jobId = accountJobCount[account] + 1;\n        accountJobCount[account]++;\n\n        // prevent user from supplying an invalid number of execution (0)\n        uint16 nrOfExecutions = uint16(bytes2(orderData[6:8]));\n        if (nrOfExecutions == 0) revert InvalidExecution();\n\n        executionLog[account][jobId] = ExecutionConfig({\n            numberOfExecutionsCompleted: 0,\n            isEnabled: true,\n            lastExecutionTime: 0,\n            executeInterval: uint48(bytes6(orderData[0:6])),\n            numberOfExecutions: nrOfExecutions,\n            startDate: uint48(bytes6(orderData[8:14])),\n            executionData: orderData[14:]\n        });\n\n        emit ExecutionAdded(account, jobId);\n    }\n\n    function _isExecutionValid(uint256 jobId) internal view {\n        ExecutionConfig storage executionConfig = executionLog[msg.sender][jobId];\n\n        if (!executionConfig.isEnabled) {\n            revert InvalidExecution();\n        }\n\n        if (executionConfig.lastExecutionTime + executionConfig.executeInterval > block.timestamp) {\n            revert InvalidExecution();\n        }\n\n        if (executionConfig.numberOfExecutionsCompleted >= executionConfig.numberOfExecutions) {\n            revert InvalidExecution();\n        }\n\n        if (executionConfig.startDate > block.timestamp) {\n            revert InvalidExecution();\n        }\n    }\n\n    modifier canExecute(uint256 jobId) {\n        _isExecutionValid(jobId);\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     METADATA\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function isModuleType(uint256 typeID) external pure override returns (bool) {\n        return typeID == TYPE_EXECUTOR;\n    }\n}\n"},"node_modules/@rhinestone/modulekit/src/module-bases/ERC7484RegistryAdapter.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nimport { IERC7484 } from \"./interfaces/IERC7484.sol\";\n\nabstract contract ERC7484RegistryAdapter {\n    // registry address\n    IERC7484 public immutable REGISTRY;\n\n    /**\n     * Contract constructor\n     * @dev sets the registry as an immutable variable\n     *\n     * @param _registry The registry address\n     */\n    constructor(IERC7484 _registry) {\n        // set the registry\n        REGISTRY = _registry;\n    }\n}\n"},"node_modules/@rhinestone/modulekit/src/module-bases/ERC7579PolicyBase.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nimport { ERC7579ModuleBase } from \"./ERC7579ModuleBase.sol\";\nimport { IPolicy, ConfigId } from \"./interfaces/IPolicy.sol\";\n\nabstract contract ERC7579PolicyBase is ERC7579ModuleBase, IPolicy {\n    function initializeWithMultiplexer(\n        address account,\n        ConfigId configId,\n        bytes calldata initData\n    )\n        external\n        virtual;\n}\n"},"node_modules/@rhinestone/modulekit/src/module-bases/ERC1271Policy.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nimport { ERC7579PolicyBase } from \"./ERC7579PolicyBase.sol\";\nimport { ConfigId, I1271Policy } from \"./interfaces/IPolicy.sol\";\n\nabstract contract ERC1271Policy is ERC7579PolicyBase, I1271Policy {\n    function check1271SignedAction(\n        ConfigId id,\n        address requestSender,\n        address account,\n        bytes32 hash,\n        bytes calldata signature\n    )\n        external\n        view\n        virtual\n        returns (bool);\n}\n"},"node_modules/@rhinestone/modulekit/src/module-bases/ERC7579ActionPolicy.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nimport { ERC7579PolicyBase } from \"./ERC7579PolicyBase.sol\";\nimport { ConfigId, IActionPolicy } from \"./interfaces/IPolicy.sol\";\n\nabstract contract ERC7579ActionPolicy is ERC7579PolicyBase, IActionPolicy {\n    function checkAction(\n        ConfigId id,\n        address account,\n        address target,\n        uint256 value,\n        bytes calldata data\n    )\n        external\n        virtual\n        returns (uint256);\n}\n"},"node_modules/@rhinestone/modulekit/src/module-bases/ERC7579UserOpPolicy.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nimport { ERC7579PolicyBase } from \"./ERC7579PolicyBase.sol\";\nimport { ConfigId, IUserOpPolicy } from \"./interfaces/IPolicy.sol\";\nimport { PackedUserOperation } from \"../external/ERC4337.sol\";\n\nabstract contract ERC7579UserOpPolicy is ERC7579PolicyBase, IUserOpPolicy {\n    function checkUserOp(\n        ConfigId id,\n        PackedUserOperation calldata userOp\n    )\n        external\n        virtual\n        returns (uint256);\n}\n"},"node_modules/@rhinestone/modulekit/src/module-bases/utils/TrustedForwarder.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nabstract contract TrustedForwarder {\n    // account => trustedForwarder\n    mapping(address account => address trustedForwarder) public trustedForwarder;\n\n    /**\n     * Set the trusted forwarder for an account\n     *\n     * @param forwarder The address of the trusted forwarder\n     */\n    function setTrustedForwarder(address forwarder) external {\n        trustedForwarder[msg.sender] = forwarder;\n    }\n\n    /**\n     * Clear the trusted forwarder for an account\n     */\n    function clearTrustedForwarder() public {\n        trustedForwarder[msg.sender] = address(0);\n    }\n\n    /**\n     * Check if a forwarder is trusted for an account\n     *\n     * @param forwarder The address of the forwarder\n     * @param account The address of the account\n     *\n     * @return true if the forwarder is trusted for the account\n     */\n    function isTrustedForwarder(address forwarder, address account) public view returns (bool) {\n        return forwarder == trustedForwarder[account];\n    }\n\n    /**\n     * Get the sender of the transaction\n     *\n     * @return account the sender of the transaction\n     */\n    function _getAccount() internal view returns (address account) {\n        account = msg.sender;\n        address _account;\n        address forwarder;\n        if (msg.data.length >= 40) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                _account := shr(96, calldataload(sub(calldatasize(), 20)))\n                forwarder := shr(96, calldataload(sub(calldatasize(), 40)))\n            }\n            if (forwarder == msg.sender && isTrustedForwarder(forwarder, _account)) {\n                account = _account;\n            }\n        }\n    }\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/interfaces/PackedUserOperation.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\n/**\n * User Operation struct\n * @param sender                - The sender account of this request.\n * @param nonce                 - Unique value the sender uses to verify it is not a replay.\n * @param initCode              - If set, the account contract will be created by this constructor/\n * @param callData              - The method call to execute on this account.\n * @param accountGasLimits      - Packed gas limits for validateUserOp and gas limit passed to the callData method call.\n * @param preVerificationGas    - Gas not calculated by the handleOps method, but added to the gas paid.\n *                                Covers batch overhead.\n * @param gasFees               - packed gas fields maxPriorityFeePerGas and maxFeePerGas - Same as EIP-1559 gas parameters.\n * @param paymasterAndData      - If set, this field holds the paymaster address, verification gas limit, postOp gas limit and paymaster-specific extra data\n *                                The paymaster will pay for the transaction instead of the sender.\n * @param signature             - Sender-verified signature over the entire request, the EntryPoint address and the chain ID.\n */\nstruct PackedUserOperation {\n    address sender;\n    uint256 nonce;\n    bytes initCode;\n    bytes callData;\n    bytes32 accountGasLimits;\n    uint256 preVerificationGas;\n    bytes32 gasFees;\n    bytes paymasterAndData;\n    bytes signature;\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/core/UserOperationLib.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.23;\n\n/* solhint-disable no-inline-assembly */\n\nimport \"../interfaces/PackedUserOperation.sol\";\nimport {calldataKeccak, min} from \"./Helpers.sol\";\n\n/**\n * Utility functions helpful when working with UserOperation structs.\n */\nlibrary UserOperationLib {\n\n    uint256 public constant PAYMASTER_VALIDATION_GAS_OFFSET = 20;\n    uint256 public constant PAYMASTER_POSTOP_GAS_OFFSET = 36;\n    uint256 public constant PAYMASTER_DATA_OFFSET = 52;\n    /**\n     * Get sender from user operation data.\n     * @param userOp - The user operation data.\n     */\n    function getSender(\n        PackedUserOperation calldata userOp\n    ) internal pure returns (address) {\n        address data;\n        //read sender from userOp, which is first userOp member (saves 800 gas...)\n        assembly {\n            data := calldataload(userOp)\n        }\n        return address(uint160(data));\n    }\n\n    /**\n     * Relayer/block builder might submit the TX with higher priorityFee,\n     * but the user should not pay above what he signed for.\n     * @param userOp - The user operation data.\n     */\n    function gasPrice(\n        PackedUserOperation calldata userOp\n    ) internal view returns (uint256) {\n        unchecked {\n            (uint256 maxPriorityFeePerGas, uint256 maxFeePerGas) = unpackUints(userOp.gasFees);\n            if (maxFeePerGas == maxPriorityFeePerGas) {\n                //legacy mode (for networks that don't support basefee opcode)\n                return maxFeePerGas;\n            }\n            return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\n        }\n    }\n\n    /**\n     * Pack the user operation data into bytes for hashing.\n     * @param userOp - The user operation data.\n     */\n    function encode(\n        PackedUserOperation calldata userOp\n    ) internal pure returns (bytes memory ret) {\n        address sender = getSender(userOp);\n        uint256 nonce = userOp.nonce;\n        bytes32 hashInitCode = calldataKeccak(userOp.initCode);\n        bytes32 hashCallData = calldataKeccak(userOp.callData);\n        bytes32 accountGasLimits = userOp.accountGasLimits;\n        uint256 preVerificationGas = userOp.preVerificationGas;\n        bytes32 gasFees = userOp.gasFees;\n        bytes32 hashPaymasterAndData = calldataKeccak(userOp.paymasterAndData);\n\n        return abi.encode(\n            sender, nonce,\n            hashInitCode, hashCallData,\n            accountGasLimits, preVerificationGas, gasFees,\n            hashPaymasterAndData\n        );\n    }\n\n    function unpackUints(\n        bytes32 packed\n    ) internal pure returns (uint256 high128, uint256 low128) {\n        return (uint128(bytes16(packed)), uint128(uint256(packed)));\n    }\n\n    //unpack just the high 128-bits from a packed value\n    function unpackHigh128(bytes32 packed) internal pure returns (uint256) {\n        return uint256(packed) >> 128;\n    }\n\n    // unpack just the low 128-bits from a packed value\n    function unpackLow128(bytes32 packed) internal pure returns (uint256) {\n        return uint128(uint256(packed));\n    }\n\n    function unpackMaxPriorityFeePerGas(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return unpackHigh128(userOp.gasFees);\n    }\n\n    function unpackMaxFeePerGas(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return unpackLow128(userOp.gasFees);\n    }\n\n    function unpackVerificationGasLimit(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return unpackHigh128(userOp.accountGasLimits);\n    }\n\n    function unpackCallGasLimit(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return unpackLow128(userOp.accountGasLimits);\n    }\n\n    function unpackPaymasterVerificationGasLimit(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return uint128(bytes16(userOp.paymasterAndData[PAYMASTER_VALIDATION_GAS_OFFSET : PAYMASTER_POSTOP_GAS_OFFSET]));\n    }\n\n    function unpackPostOpGasLimit(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return uint128(bytes16(userOp.paymasterAndData[PAYMASTER_POSTOP_GAS_OFFSET : PAYMASTER_DATA_OFFSET]));\n    }\n\n    function unpackPaymasterStaticFields(\n        bytes calldata paymasterAndData\n    ) internal pure returns (address paymaster, uint256 validationGasLimit, uint256 postOpGasLimit) {\n        return (\n            address(bytes20(paymasterAndData[: PAYMASTER_VALIDATION_GAS_OFFSET])),\n            uint128(bytes16(paymasterAndData[PAYMASTER_VALIDATION_GAS_OFFSET : PAYMASTER_POSTOP_GAS_OFFSET])),\n            uint128(bytes16(paymasterAndData[PAYMASTER_POSTOP_GAS_OFFSET : PAYMASTER_DATA_OFFSET]))\n        );\n    }\n\n    /**\n     * Hash the user operation data.\n     * @param userOp - The user operation data.\n     */\n    function hash(\n        PackedUserOperation calldata userOp\n    ) internal pure returns (bytes32) {\n        return keccak256(encode(userOp));\n    }\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/core/EntryPointSimulations.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.23;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n\nimport \"./EntryPoint.sol\";\nimport \"../interfaces/IEntryPointSimulations.sol\";\n\n/*\n * This contract inherits the EntryPoint and extends it with the view-only methods that are executed by\n * the bundler in order to check UserOperation validity and estimate its gas consumption.\n * This contract should never be deployed on-chain and is only used as a parameter for the \"eth_call\" request.\n */\ncontract EntryPointSimulations is EntryPoint, IEntryPointSimulations {\n    // solhint-disable-next-line var-name-mixedcase\n    AggregatorStakeInfo private NOT_AGGREGATED = AggregatorStakeInfo(address(0), StakeInfo(0, 0));\n\n    SenderCreator private _senderCreator;\n\n    function initSenderCreator() internal virtual {\n        //this is the address of the first contract created with CREATE by this address.\n        address createdObj = address(uint160(uint256(keccak256(abi.encodePacked(hex\"d694\", address(this), hex\"01\")))));\n        _senderCreator = SenderCreator(createdObj);\n    }\n\n    function senderCreator() internal view virtual override returns (SenderCreator) {\n        // return the same senderCreator as real EntryPoint.\n        // this call is slightly (100) more expensive than EntryPoint's access to immutable member\n        return _senderCreator;\n    }\n\n    /**\n     * simulation contract should not be deployed, and specifically, accounts should not trust\n     * it as entrypoint, since the simulation functions don't check the signatures\n     */\n    constructor() {\n        // THIS CONTRACT SHOULD NOT BE DEPLOYED\n        // however, the line of code below is commented to allow this entryPoint to be used in fork tests\n        // require(block.number < 100, \"should not be deployed\");\n    }\n\n    /// @inheritdoc IEntryPointSimulations\n    function simulateValidation(\n        PackedUserOperation calldata userOp\n    )\n    external\n    returns (\n        ValidationResult memory\n    ){\n        UserOpInfo memory outOpInfo;\n\n        _simulationOnlyValidations(userOp);\n        (\n            uint256 validationData,\n            uint256 paymasterValidationData\n        ) = _validatePrepayment(0, userOp, outOpInfo);\n        StakeInfo memory paymasterInfo = _getStakeInfo(\n            outOpInfo.mUserOp.paymaster\n        );\n        StakeInfo memory senderInfo = _getStakeInfo(outOpInfo.mUserOp.sender);\n        StakeInfo memory factoryInfo;\n        {\n            bytes calldata initCode = userOp.initCode;\n            address factory = initCode.length >= 20\n                ? address(bytes20(initCode[0 : 20]))\n                : address(0);\n            factoryInfo = _getStakeInfo(factory);\n        }\n\n        address aggregator = address(uint160(validationData));\n        ReturnInfo memory returnInfo = ReturnInfo(\n            outOpInfo.preOpGas,\n            outOpInfo.prefund,\n            validationData,\n            paymasterValidationData,\n            getMemoryBytesFromOffset(outOpInfo.contextOffset)\n        );\n\n        AggregatorStakeInfo memory aggregatorInfo = NOT_AGGREGATED;\n        if (uint160(aggregator) != SIG_VALIDATION_SUCCESS && uint160(aggregator) != SIG_VALIDATION_FAILED) {\n            aggregatorInfo = AggregatorStakeInfo(\n                aggregator,\n                _getStakeInfo(aggregator)\n            );\n        }\n        return ValidationResult(\n            returnInfo,\n            senderInfo,\n            factoryInfo,\n            paymasterInfo,\n            aggregatorInfo\n        );\n    }\n\n    /// @inheritdoc IEntryPointSimulations\n    function simulateHandleOp(\n        PackedUserOperation calldata op,\n        address target,\n        bytes calldata targetCallData\n    )\n    external nonReentrant\n    returns (\n        ExecutionResult memory\n    ){\n        UserOpInfo memory opInfo;\n        _simulationOnlyValidations(op);\n        (\n            uint256 validationData,\n            uint256 paymasterValidationData\n        ) = _validatePrepayment(0, op, opInfo);\n\n        uint256 paid = _executeUserOp(0, op, opInfo);\n        bool targetSuccess;\n        bytes memory targetResult;\n        if (target != address(0)) {\n            (targetSuccess, targetResult) = target.call(targetCallData);\n        }\n        return ExecutionResult(\n            opInfo.preOpGas,\n            paid,\n            validationData,\n            paymasterValidationData,\n            targetSuccess,\n            targetResult\n        );\n    }\n\n    function _simulationOnlyValidations(\n        PackedUserOperation calldata userOp\n    )\n    internal\n    {\n        //initialize senderCreator(). we can't rely on constructor\n        initSenderCreator();\n\n        try\n        this._validateSenderAndPaymaster(\n            userOp.initCode,\n            userOp.sender,\n            userOp.paymasterAndData\n        )\n        // solhint-disable-next-line no-empty-blocks\n        {} catch Error(string memory revertReason) {\n            if (bytes(revertReason).length != 0) {\n                revert FailedOp(0, revertReason);\n            }\n        }\n    }\n\n    /**\n     * Called only during simulation.\n     * This function always reverts to prevent warm/cold storage differentiation in simulation vs execution.\n     * @param initCode         - The smart account constructor code.\n     * @param sender           - The sender address.\n     * @param paymasterAndData - The paymaster address (followed by other params, ignored by this method)\n     */\n    function _validateSenderAndPaymaster(\n        bytes calldata initCode,\n        address sender,\n        bytes calldata paymasterAndData\n    ) external view {\n        if (initCode.length == 0 && sender.code.length == 0) {\n            // it would revert anyway. but give a meaningful message\n            revert(\"AA20 account not deployed\");\n        }\n        if (paymasterAndData.length >= 20) {\n            address paymaster = address(bytes20(paymasterAndData[0 : 20]));\n            if (paymaster.code.length == 0) {\n                // It would revert anyway. but give a meaningful message.\n                revert(\"AA30 paymaster not deployed\");\n            }\n        }\n        // always revert\n        revert(\"\");\n    }\n\n    //make sure depositTo cost is more than normal EntryPoint's cost,\n    // to mitigate DoS vector on the bundler\n    // empiric test showed that without this wrapper, simulation depositTo costs less..\n    function depositTo(address account) public override(IStakeManager, StakeManager) payable {\n        unchecked{\n        // silly code, to waste some gas to make sure depositTo is always little more\n        // expensive than on-chain call\n            uint256 x = 1;\n            while (x < 5) {\n                x++;\n            }\n            StakeManager.depositTo(account);\n        }\n    }\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/core/Helpers.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.23;\n\n/* solhint-disable no-inline-assembly */\n\n\n /*\n  * For simulation purposes, validateUserOp (and validatePaymasterUserOp)\n  * must return this value in case of signature failure, instead of revert.\n  */\nuint256 constant SIG_VALIDATION_FAILED = 1;\n\n\n/*\n * For simulation purposes, validateUserOp (and validatePaymasterUserOp)\n * return this value on success.\n */\nuint256 constant SIG_VALIDATION_SUCCESS = 0;\n\n\n/**\n * Returned data from validateUserOp.\n * validateUserOp returns a uint256, which is created by `_packedValidationData` and\n * parsed by `_parseValidationData`.\n * @param aggregator  - address(0) - The account validated the signature by itself.\n *                      address(1) - The account failed to validate the signature.\n *                      otherwise - This is an address of a signature aggregator that must\n *                                  be used to validate the signature.\n * @param validAfter  - This UserOp is valid only after this timestamp.\n * @param validaUntil - This UserOp is valid only up to this timestamp.\n */\nstruct ValidationData {\n    address aggregator;\n    uint48 validAfter;\n    uint48 validUntil;\n}\n\n/**\n * Extract sigFailed, validAfter, validUntil.\n * Also convert zero validUntil to type(uint48).max.\n * @param validationData - The packed validation data.\n */\nfunction _parseValidationData(\n    uint256 validationData\n) pure returns (ValidationData memory data) {\n    address aggregator = address(uint160(validationData));\n    uint48 validUntil = uint48(validationData >> 160);\n    if (validUntil == 0) {\n        validUntil = type(uint48).max;\n    }\n    uint48 validAfter = uint48(validationData >> (48 + 160));\n    return ValidationData(aggregator, validAfter, validUntil);\n}\n\n/**\n * Helper to pack the return value for validateUserOp.\n * @param data - The ValidationData to pack.\n */\nfunction _packValidationData(\n    ValidationData memory data\n) pure returns (uint256) {\n    return\n        uint160(data.aggregator) |\n        (uint256(data.validUntil) << 160) |\n        (uint256(data.validAfter) << (160 + 48));\n}\n\n/**\n * Helper to pack the return value for validateUserOp, when not using an aggregator.\n * @param sigFailed  - True for signature failure, false for success.\n * @param validUntil - Last timestamp this UserOperation is valid (or zero for infinite).\n * @param validAfter - First timestamp this UserOperation is valid.\n */\nfunction _packValidationData(\n    bool sigFailed,\n    uint48 validUntil,\n    uint48 validAfter\n) pure returns (uint256) {\n    return\n        (sigFailed ? 1 : 0) |\n        (uint256(validUntil) << 160) |\n        (uint256(validAfter) << (160 + 48));\n}\n\n/**\n * keccak function over calldata.\n * @dev copy calldata into memory, do keccak and drop allocated memory. Strangely, this is more efficient than letting solidity do it.\n */\n    function calldataKeccak(bytes calldata data) pure returns (bytes32 ret) {\n        assembly (\"memory-safe\") {\n            let mem := mload(0x40)\n            let len := data.length\n            calldatacopy(mem, data.offset, len)\n            ret := keccak256(mem, len)\n        }\n    }\n\n\n/**\n * The minimum of two numbers.\n * @param a - First number.\n * @param b - Second number.\n */\n    function min(uint256 a, uint256 b) pure returns (uint256) {\n        return a < b ? a : b;\n    }\n"},"node_modules/@ERC4337/account-abstraction/contracts/interfaces/IStakeManager.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.7.5;\n\n/**\n * Manage deposits and stakes.\n * Deposit is just a balance used to pay for UserOperations (either by a paymaster or an account).\n * Stake is value locked for at least \"unstakeDelay\" by the staked entity.\n */\ninterface IStakeManager {\n    event Deposited(address indexed account, uint256 totalDeposit);\n\n    event Withdrawn(\n        address indexed account,\n        address withdrawAddress,\n        uint256 amount\n    );\n\n    // Emitted when stake or unstake delay are modified.\n    event StakeLocked(\n        address indexed account,\n        uint256 totalStaked,\n        uint256 unstakeDelaySec\n    );\n\n    // Emitted once a stake is scheduled for withdrawal.\n    event StakeUnlocked(address indexed account, uint256 withdrawTime);\n\n    event StakeWithdrawn(\n        address indexed account,\n        address withdrawAddress,\n        uint256 amount\n    );\n\n    /**\n     * @param deposit         - The entity's deposit.\n     * @param staked          - True if this entity is staked.\n     * @param stake           - Actual amount of ether staked for this entity.\n     * @param unstakeDelaySec - Minimum delay to withdraw the stake.\n     * @param withdrawTime    - First block timestamp where 'withdrawStake' will be callable, or zero if already locked.\n     * @dev Sizes were chosen so that deposit fits into one cell (used during handleOp)\n     *      and the rest fit into a 2nd cell (used during stake/unstake)\n     *      - 112 bit allows for 10^15 eth\n     *      - 48 bit for full timestamp\n     *      - 32 bit allows 150 years for unstake delay\n     */\n    struct DepositInfo {\n        uint256 deposit;\n        bool staked;\n        uint112 stake;\n        uint32 unstakeDelaySec;\n        uint48 withdrawTime;\n    }\n\n    // API struct used by getStakeInfo and simulateValidation.\n    struct StakeInfo {\n        uint256 stake;\n        uint256 unstakeDelaySec;\n    }\n\n    /**\n     * Get deposit info.\n     * @param account - The account to query.\n     * @return info   - Full deposit information of given account.\n     */\n    function getDepositInfo(\n        address account\n    ) external view returns (DepositInfo memory info);\n\n    /**\n     * Get account balance.\n     * @param account - The account to query.\n     * @return        - The deposit (for gas payment) of the account.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * Add to the deposit of the given account.\n     * @param account - The account to add to.\n     */\n    function depositTo(address account) external payable;\n\n    /**\n     * Add to the account's stake - amount and delay\n     * any pending unstake is first cancelled.\n     * @param _unstakeDelaySec - The new lock duration before the deposit can be withdrawn.\n     */\n    function addStake(uint32 _unstakeDelaySec) external payable;\n\n    /**\n     * Attempt to unlock the stake.\n     * The value can be withdrawn (using withdrawStake) after the unstake delay.\n     */\n    function unlockStake() external;\n\n    /**\n     * Withdraw from the (unlocked) stake.\n     * Must first call unlockStake and wait for the unstakeDelay to pass.\n     * @param withdrawAddress - The address to send withdrawn value.\n     */\n    function withdrawStake(address payable withdrawAddress) external;\n\n    /**\n     * Withdraw from the deposit.\n     * @param withdrawAddress - The address to send withdrawn value.\n     * @param withdrawAmount  - The amount to withdraw.\n     */\n    function withdrawTo(\n        address payable withdrawAddress,\n        uint256 withdrawAmount\n    ) external;\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/interfaces/IAccount.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./PackedUserOperation.sol\";\n\ninterface IAccount {\n    /**\n     * Validate user's signature and nonce\n     * the entryPoint will make the call to the recipient only if this validation call returns successfully.\n     * signature failure should be reported by returning SIG_VALIDATION_FAILED (1).\n     * This allows making a \"simulation call\" without a valid signature\n     * Other failures (e.g. nonce mismatch, or invalid signature format) should still revert to signal failure.\n     *\n     * @dev Must validate caller is the entryPoint.\n     *      Must validate the signature and nonce\n     * @param userOp              - The operation that is about to be executed.\n     * @param userOpHash          - Hash of the user's request data. can be used as the basis for signature.\n     * @param missingAccountFunds - Missing funds on the account's deposit in the entrypoint.\n     *                              This is the minimum amount to transfer to the sender(entryPoint) to be\n     *                              able to make the call. The excess is left as a deposit in the entrypoint\n     *                              for future calls. Can be withdrawn anytime using \"entryPoint.withdrawTo()\".\n     *                              In case there is a paymaster in the request (or the current deposit is high\n     *                              enough), this value will be zero.\n     * @return validationData       - Packaged ValidationData structure. use `_packValidationData` and\n     *                              `_unpackValidationData` to encode and decode.\n     *                              <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\n     *                                 otherwise, an address of an \"authorizer\" contract.\n     *                              <6-byte> validUntil - Last timestamp this operation is valid. 0 for \"indefinite\"\n     *                              <6-byte> validAfter - First timestamp this operation is valid\n     *                                                    If an account doesn't use time-range, it is enough to\n     *                                                    return SIG_VALIDATION_FAILED value (1) for signature failure.\n     *                              Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    ) external returns (uint256 validationData);\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/interfaces/IAccountExecute.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./PackedUserOperation.sol\";\n\ninterface IAccountExecute {\n    /**\n     * Account may implement this execute method.\n     * passing this methodSig at the beginning of callData will cause the entryPoint to pass the full UserOp (and hash)\n     * to the account.\n     * The account should skip the methodSig, and use the callData (and optionally, other UserOp fields)\n     *\n     * @param userOp              - The operation that was just validated.\n     * @param userOpHash          - Hash of the user's request data.\n     */\n    function executeUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash\n    ) external;\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/interfaces/IEntryPoint.sol":{"content":"/**\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\n ** Only one instance required on each chain.\n **/\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable reason-string */\n\nimport \"./PackedUserOperation.sol\";\nimport \"./IStakeManager.sol\";\nimport \"./IAggregator.sol\";\nimport \"./INonceManager.sol\";\n\ninterface IEntryPoint is IStakeManager, INonceManager {\n    /***\n     * An event emitted after each successful request.\n     * @param userOpHash    - Unique identifier for the request (hash its entire content, except signature).\n     * @param sender        - The account that generates this request.\n     * @param paymaster     - If non-null, the paymaster that pays for this request.\n     * @param nonce         - The nonce value from the request.\n     * @param success       - True if the sender transaction succeeded, false if reverted.\n     * @param actualGasCost - Actual amount paid (by account or paymaster) for this UserOperation.\n     * @param actualGasUsed - Total gas used by this UserOperation (including preVerification, creation,\n     *                        validation and execution).\n     */\n    event UserOperationEvent(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        address indexed paymaster,\n        uint256 nonce,\n        bool success,\n        uint256 actualGasCost,\n        uint256 actualGasUsed\n    );\n\n    /**\n     * Account \"sender\" was deployed.\n     * @param userOpHash - The userOp that deployed this account. UserOperationEvent will follow.\n     * @param sender     - The account that is deployed\n     * @param factory    - The factory used to deploy this account (in the initCode)\n     * @param paymaster  - The paymaster used by this UserOp\n     */\n    event AccountDeployed(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        address factory,\n        address paymaster\n    );\n\n    /**\n     * An event emitted if the UserOperation \"callData\" reverted with non-zero length.\n     * @param userOpHash   - The request unique identifier.\n     * @param sender       - The sender of this request.\n     * @param nonce        - The nonce used in the request.\n     * @param revertReason - The return bytes from the (reverted) call to \"callData\".\n     */\n    event UserOperationRevertReason(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        uint256 nonce,\n        bytes revertReason\n    );\n\n    /**\n     * An event emitted if the UserOperation Paymaster's \"postOp\" call reverted with non-zero length.\n     * @param userOpHash   - The request unique identifier.\n     * @param sender       - The sender of this request.\n     * @param nonce        - The nonce used in the request.\n     * @param revertReason - The return bytes from the (reverted) call to \"callData\".\n     */\n    event PostOpRevertReason(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        uint256 nonce,\n        bytes revertReason\n    );\n\n    /**\n     * UserOp consumed more than prefund. The UserOperation is reverted, and no refund is made.\n     * @param userOpHash   - The request unique identifier.\n     * @param sender       - The sender of this request.\n     * @param nonce        - The nonce used in the request.\n     */\n    event UserOperationPrefundTooLow(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        uint256 nonce\n    );\n\n    /**\n     * An event emitted by handleOps(), before starting the execution loop.\n     * Any event emitted before this event, is part of the validation.\n     */\n    event BeforeExecution();\n\n    /**\n     * Signature aggregator used by the following UserOperationEvents within this bundle.\n     * @param aggregator - The aggregator used for the following UserOperationEvents.\n     */\n    event SignatureAggregatorChanged(address indexed aggregator);\n\n    /**\n     * A custom revert error of handleOps, to identify the offending op.\n     * Should be caught in off-chain handleOps simulation and not happen on-chain.\n     * Useful for mitigating DoS attempts against batchers or for troubleshooting of factory/account/paymaster reverts.\n     * NOTE: If simulateValidation passes successfully, there should be no reason for handleOps to fail on it.\n     * @param opIndex - Index into the array of ops to the failed one (in simulateValidation, this is always zero).\n     * @param reason  - Revert reason. The string starts with a unique code \"AAmn\",\n     *                  where \"m\" is \"1\" for factory, \"2\" for account and \"3\" for paymaster issues,\n     *                  so a failure can be attributed to the correct entity.\n     */\n    error FailedOp(uint256 opIndex, string reason);\n\n    /**\n     * A custom revert error of handleOps, to report a revert by account or paymaster.\n     * @param opIndex - Index into the array of ops to the failed one (in simulateValidation, this is always zero).\n     * @param reason  - Revert reason. see FailedOp(uint256,string), above\n     * @param inner   - data from inner cought revert reason\n     * @dev note that inner is truncated to 2048 bytes\n     */\n    error FailedOpWithRevert(uint256 opIndex, string reason, bytes inner);\n\n    error PostOpReverted(bytes returnData);\n\n    /**\n     * Error case when a signature aggregator fails to verify the aggregated signature it had created.\n     * @param aggregator The aggregator that failed to verify the signature\n     */\n    error SignatureValidationFailed(address aggregator);\n\n    // Return value of getSenderAddress.\n    error SenderAddressResult(address sender);\n\n    // UserOps handled, per aggregator.\n    struct UserOpsPerAggregator {\n        PackedUserOperation[] userOps;\n        // Aggregator address\n        IAggregator aggregator;\n        // Aggregated signature\n        bytes signature;\n    }\n\n    /**\n     * Execute a batch of UserOperations.\n     * No signature aggregator is used.\n     * If any account requires an aggregator (that is, it returned an aggregator when\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\n     * @param ops         - The operations to execute.\n     * @param beneficiary - The address to receive the fees.\n     */\n    function handleOps(\n        PackedUserOperation[] calldata ops,\n        address payable beneficiary\n    ) external;\n\n    /**\n     * Execute a batch of UserOperation with Aggregators\n     * @param opsPerAggregator - The operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts).\n     * @param beneficiary      - The address to receive the fees.\n     */\n    function handleAggregatedOps(\n        UserOpsPerAggregator[] calldata opsPerAggregator,\n        address payable beneficiary\n    ) external;\n\n    /**\n     * Generate a request Id - unique identifier for this request.\n     * The request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\n     * @param userOp - The user operation to generate the request ID for.\n     * @return hash the hash of this UserOperation\n     */\n    function getUserOpHash(\n        PackedUserOperation calldata userOp\n    ) external view returns (bytes32);\n\n    /**\n     * Gas and return values during simulation.\n     * @param preOpGas         - The gas used for validation (including preValidationGas)\n     * @param prefund          - The required prefund for this operation\n     * @param accountValidationData   - returned validationData from account.\n     * @param paymasterValidationData - return validationData from paymaster.\n     * @param paymasterContext - Returned by validatePaymasterUserOp (to be passed into postOp)\n     */\n    struct ReturnInfo {\n        uint256 preOpGas;\n        uint256 prefund;\n        uint256 accountValidationData;\n        uint256 paymasterValidationData;\n        bytes paymasterContext;\n    }\n\n    /**\n     * Returned aggregated signature info:\n     * The aggregator returned by the account, and its current stake.\n     */\n    struct AggregatorStakeInfo {\n        address aggregator;\n        StakeInfo stakeInfo;\n    }\n\n    /**\n     * Get counterfactual sender address.\n     * Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\n     * This method always revert, and returns the address in SenderAddressResult error\n     * @param initCode - The constructor code to be passed into the UserOperation.\n     */\n    function getSenderAddress(bytes memory initCode) external;\n\n    error DelegateAndRevert(bool success, bytes ret);\n\n    /**\n     * Helper method for dry-run testing.\n     * @dev calling this method, the EntryPoint will make a delegatecall to the given data, and report (via revert) the result.\n     *  The method always revert, so is only useful off-chain for dry run calls, in cases where state-override to replace\n     *  actual EntryPoint code is less convenient.\n     * @param target a target contract to make a delegatecall from entrypoint\n     * @param data data to pass to target in a delegatecall\n     */\n    function delegateAndRevert(address target, bytes calldata data) external;\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/interfaces/IEntryPointSimulations.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./PackedUserOperation.sol\";\nimport \"./IEntryPoint.sol\";\n\ninterface IEntryPointSimulations is IEntryPoint {\n    // Return value of simulateHandleOp.\n    struct ExecutionResult {\n        uint256 preOpGas;\n        uint256 paid;\n        uint256 accountValidationData;\n        uint256 paymasterValidationData;\n        bool targetSuccess;\n        bytes targetResult;\n    }\n\n    /**\n     * Successful result from simulateValidation.\n     * If the account returns a signature aggregator the \"aggregatorInfo\" struct is filled in as well.\n     * @param returnInfo     Gas and time-range returned values\n     * @param senderInfo     Stake information about the sender\n     * @param factoryInfo    Stake information about the factory (if any)\n     * @param paymasterInfo  Stake information about the paymaster (if any)\n     * @param aggregatorInfo Signature aggregation info (if the account requires signature aggregator)\n     *                       Bundler MUST use it to verify the signature, or reject the UserOperation.\n     */\n    struct ValidationResult {\n        ReturnInfo returnInfo;\n        StakeInfo senderInfo;\n        StakeInfo factoryInfo;\n        StakeInfo paymasterInfo;\n        AggregatorStakeInfo aggregatorInfo;\n    }\n\n    /**\n     * Simulate a call to account.validateUserOp and paymaster.validatePaymasterUserOp.\n     * @dev The node must also verify it doesn't use banned opcodes, and that it doesn't reference storage\n     *      outside the account's data.\n     * @param userOp - The user operation to validate.\n     * @return the validation result structure\n     */\n    function simulateValidation(\n        PackedUserOperation calldata userOp\n    )\n    external\n    returns (\n        ValidationResult memory\n    );\n\n    /**\n     * Simulate full execution of a UserOperation (including both validation and target execution)\n     * It performs full validation of the UserOperation, but ignores signature error.\n     * An optional target address is called after the userop succeeds,\n     * and its value is returned (before the entire call is reverted).\n     * Note that in order to collect the the success/failure of the target call, it must be executed\n     * with trace enabled to track the emitted events.\n     * @param op The UserOperation to simulate.\n     * @param target         - If nonzero, a target address to call after userop simulation. If called,\n     *                         the targetSuccess and targetResult are set to the return from that call.\n     * @param targetCallData - CallData to pass to target address.\n     * @return the execution result structure\n     */\n    function simulateHandleOp(\n        PackedUserOperation calldata op,\n        address target,\n        bytes calldata targetCallData\n    )\n    external\n    returns (\n        ExecutionResult memory\n    );\n}\n"},"node_modules/@rhinestone/modulekit/src/accounts/common/interfaces/IERC7579Account.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.23 <0.9.0;\n\n/* solhint-disable no-unused-import */\n\n// Types\nimport { CallType, ExecType, ModeCode } from \"../lib/ModeLib.sol\";\n\n// Structs\nstruct Execution {\n    address target;\n    uint256 value;\n    bytes callData;\n}\n\ninterface IERC7579Account {\n    event ModuleInstalled(uint256 moduleTypeId, address module);\n    event ModuleUninstalled(uint256 moduleTypeId, address module);\n\n    /**\n     * @dev Executes a transaction on behalf of the account.\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\n     * @dev Ensure adequate authorization control: i.e. onlyEntryPointOrSelf\n     *\n     * @dev MSA MUST implement this function signature.\n     * If a mode is requested that is not supported by the Account, it MUST revert\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\n     * @param executionCalldata The encoded execution call data\n     */\n    function execute(ModeCode mode, bytes calldata executionCalldata) external payable;\n\n    /**\n     * @dev Executes a transaction on behalf of the account.\n     *         This function is intended to be called by Executor Modules\n     * @dev Ensure adequate authorization control: i.e. onlyExecutorModule\n     *\n     * @dev MSA MUST implement this function signature.\n     * If a mode is requested that is not supported by the Account, it MUST revert\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\n     * @param executionCalldata The encoded execution call data\n     */\n    function executeFromExecutor(\n        ModeCode mode,\n        bytes calldata executionCalldata\n    )\n        external\n        payable\n        returns (bytes[] memory returnData);\n\n    /**\n     * @dev ERC-1271 isValidSignature\n     *         This function is intended to be used to validate a smart account signature\n     * and may forward the call to a validator module\n     *\n     * @param hash The hash of the data that is signed\n     * @param data The data that is signed\n     */\n    function isValidSignature(bytes32 hash, bytes calldata data) external view returns (bytes4);\n\n    /**\n     * @dev installs a Module of a certain type on the smart account\n     * @dev Implement Authorization control of your chosing\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     * @param module the module address\n     * @param initData arbitrary data that may be required on the module during `onInstall`\n     * initialization.\n     */\n    function installModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata initData\n    )\n        external\n        payable;\n\n    /**\n     * @dev uninstalls a Module of a certain type on the smart account\n     * @dev Implement Authorization control of your chosing\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     * @param module the module address\n     * @param deInitData arbitrary data that may be required on the module during `onUninstall`\n     * de-initialization.\n     */\n    function uninstallModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata deInitData\n    )\n        external\n        payable;\n\n    /**\n     * Function to check if the account supports a certain CallType or ExecType (see ModeLib.sol)\n     * @param encodedMode the encoded mode\n     */\n    function supportsExecutionMode(ModeCode encodedMode) external view returns (bool);\n\n    /**\n     * Function to check if the account supports installation of a certain module type Id\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     */\n    function supportsModule(uint256 moduleTypeId) external view returns (bool);\n\n    /**\n     * Function to check if the account has a certain module installed\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     *      Note: keep in mind that some contracts can be multiple module types at the same time. It\n     *            thus may be necessary to query multiple module types\n     * @param module the module address\n     * @param additionalContext additional context data that the smart account may interpret to\n     *                          identifiy conditions under which the module is installed.\n     *                          usually this is not necessary, but for some special hooks that\n     *                          are stored in mappings, this param might be needed\n     */\n    function isModuleInstalled(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata additionalContext\n    )\n        external\n        view\n        returns (bool);\n\n    /**\n     * @dev Returns the account id of the smart account\n     * @return accountImplementationId the account id of the smart account\n     * the accountId should be structured like so:\n     *        \"vendorname.accountname.semver\"\n     */\n    function accountId() external view returns (string memory accountImplementationId);\n}\n"},"node_modules/@rhinestone/modulekit/src/accounts/erc7579/interfaces/IMSA.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.23 <0.9.0;\n\n// Interfaces\nimport { IERC7579Account } from \"../../common/interfaces/IERC7579Account.sol\";\nimport { IERC4337Account } from \"../../common/interfaces/IERC4337Account.sol\";\n\n// Types\nimport { CallType, ExecType } from \"../../common/lib/ModeLib.sol\";\n\ninterface IMSA is IERC7579Account, IERC4337Account {\n    // Error thrown when an unsupported ModuleType is requested\n    error UnsupportedModuleType(uint256 moduleTypeId);\n    // Error thrown when an execution with an unsupported CallType was made\n    error UnsupportedCallType(CallType callType);\n    // Error thrown when an execution with an unsupported ExecType was made\n    error UnsupportedExecType(ExecType execType);\n    // Error thrown when account initialization fails\n    error AccountInitializationFailed();\n    // Error thrown when account installs/unistalls module with mismatched input `moduleTypeId`\n    error MismatchModuleTypeId(uint256 moduleTypeId);\n\n    /**\n     * @dev Initializes the account. Function might be called directly, or by a Factory\n     * @param data. encoded data that can be used during the initialization phase\n     */\n    function initializeAccount(bytes calldata data) external payable;\n}\n"},"node_modules/@rhinestone/modulekit/src/accounts/kernel/interfaces/IERC7579Account.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.23 <0.9.0;\n\n/* solhint-disable no-unused-import */\n\n// Types\nimport { CallType, ExecType, ExecMode } from \"../lib/ExecLib.sol\";\nimport { PackedUserOperation } from\n    \"@ERC4337/account-abstraction/contracts/core/UserOperationLib.sol\";\n\n// Structs\nstruct Execution {\n    address target;\n    uint256 value;\n    bytes callData;\n}\n\ninterface IERC7579Account {\n    event ModuleInstalled(uint256 moduleTypeId, address module);\n    event ModuleUninstalled(uint256 moduleTypeId, address module);\n\n    /**\n     * @dev Executes a transaction on behalf of the account.\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\n     * @dev Ensure adequate authorization control: i.e. onlyEntryPointOrSelf\n     *\n     * @dev MSA MUST implement this function signature.\n     * If a mode is requested that is not supported by the Account, it MUST revert\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\n     * @param executionCalldata The encoded execution call data\n     */\n    function execute(ExecMode mode, bytes calldata executionCalldata) external payable;\n\n    /**\n     * @dev Executes a transaction on behalf of the account.\n     *         This function is intended to be called by Executor Modules\n     * @dev Ensure adequate authorization control: i.e. onlyExecutorModule\n     *\n     * @dev MSA MUST implement this function signature.\n     * If a mode is requested that is not supported by the Account, it MUST revert\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\n     * @param executionCalldata The encoded execution call data\n     */\n    function executeFromExecutor(\n        ExecMode mode,\n        bytes calldata executionCalldata\n    )\n        external\n        payable\n        returns (bytes[] memory returnData);\n\n    /**\n     * @dev ERC-1271 isValidSignature\n     *         This function is intended to be used to validate a smart account signature\n     * and may forward the call to a validator module\n     *\n     * @param hash The hash of the data that is signed\n     * @param data The data that is signed\n     */\n    function isValidSignature(bytes32 hash, bytes calldata data) external view returns (bytes4);\n\n    /**\n     * @dev installs a Module of a certain type on the smart account\n     * @dev Implement Authorization control of your choosing\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     * @param module the module address\n     * @param initData arbitrary data that may be required on the module during `onInstall`\n     * initialization.\n     */\n    function installModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata initData\n    )\n        external\n        payable;\n\n    /**\n     * @dev uninstalls a Module of a certain type on the smart account\n     * @dev Implement Authorization control of your choosing\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     * @param module the module address\n     * @param deInitData arbitrary data that may be required on the module during `onUninstall`\n     * de-initialization.\n     */\n    function uninstallModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata deInitData\n    )\n        external\n        payable;\n\n    /**\n     * Function to check if the account supports a certain CallType or ExecType (see ModeLib.sol)\n     * @param encodedMode the encoded mode\n     */\n    function supportsExecutionMode(ExecMode encodedMode) external view returns (bool);\n\n    /**\n     * Function to check if the account supports installation of a certain module type Id\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     */\n    function supportsModule(uint256 moduleTypeId) external view returns (bool);\n\n    /**\n     * Function to check if the account has a certain module installed\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     *      Note: keep in mind that some contracts can be multiple module types at the same time. It\n     *            thus may be necessary to query multiple module types\n     * @param module the module address\n     * @param additionalContext additional context data that the smart account may interpret to\n     *                          identify conditions under which the module is installed.\n     *                          usually this is not necessary, but for some special hooks that\n     *                          are stored in mappings, this param might be needed\n     */\n    function isModuleInstalled(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata additionalContext\n    )\n        external\n        view\n        returns (bool);\n\n    /**\n     * @dev Returns the account id of the smart account\n     * @return accountImplementationId the account id of the smart account\n     * the accountId should be structured like so:\n     *        \"vendorname.accountname.semver\"\n     */\n    function accountId() external view returns (string memory accountImplementationId);\n}\n"},"node_modules/@rhinestone/modulekit/src/accounts/safe/interfaces/ISafe7579.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.23 <0.9.0;\n\n// Interfaces\nimport { IERC7579Account } from \"./IERC7579Account.sol\";\nimport { ISafeOp } from \"./ISafeOp.sol\";\n\n// Types\nimport \"../types/DataTypes.sol\";\nimport { ModeCode } from \"../../common/lib/ModeLib.sol\";\nimport { PackedUserOperation } from\n    \"@ERC4337/account-abstraction/contracts/core/UserOperationLib.sol\";\n\n/**\n * @title ERC7579 Adapter for Safe accounts.\n * creates full ERC7579 compliance to Safe accounts\n * @author rhinestone | zeroknots.eth, Konrad Kopp (@kopy-kat)\n */\ninterface ISafe7579 is IERC7579Account, ISafeOp {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         Validation                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * ERC4337 v0.7 validation function\n     * @dev expects that a ERC7579 validator module is encoded within the UserOp nonce.\n     *         if no validator module is provided, it will fallback to validate the transaction with\n     *         Safe's signers\n     */\n    function validateUserOp(\n        PackedUserOperation memory userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    )\n        external\n        returns (uint256 packedValidSig);\n\n    /**\n     * Will use Safe's signed messages or checkSignatures features or ERC7579 validation modules\n     * if no signature is provided, it makes use of Safe's signedMessages\n     * if address(0) or a non-installed validator module is provided, it will use Safe's\n     * checkSignatures\n     * if a valid validator module is provided, it will use the module's validateUserOp function\n     *    @param hash message hash of ERC1271 request\n     *    @param data abi.encodePacked(address validationModule, bytes signatures)\n     */\n    function isValidSignature(\n        bytes32 hash,\n        bytes memory data\n    )\n        external\n        view\n        returns (bytes4 magicValue);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         Executions                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @dev Executes a transaction on behalf of the Safe account.\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\n     * @dev If a global hook and/or selector hook is set, it will be called\n     * @dev AccessControl: only Self of Entrypoint can install modules\n     * Safe7579 supports the following feature set:\n     *    CallTypes:\n     *             - CALLTYPE_SINGLE\n     *             - CALLTYPE_BATCH\n     *             - CALLTYPE_DELEGATECALL\n     *    ExecTypes:\n     *             - EXECTYPE_DEFAULT (revert if not successful)\n     *             - EXECTYPE_TRY\n     *    If a different mode is selected, this function will revert\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\n     * @param executionCalldata The encoded execution call data\n     */\n    function execute(ModeCode mode, bytes memory executionCalldata) external;\n\n    /**\n     * @dev Executes a transaction on behalf of the Safe account.\n     *         This function is intended to be called by executor modules\n     * @dev If a global hook and/or selector hook is set, it will be called\n     * @dev AccessControl: only enabled executor modules\n     * Safe7579 supports the following feature set:\n     *    CallTypes:\n     *             - CALLTYPE_SINGLE\n     *             - CALLTYPE_BATCH\n     *             - CALLTYPE_DELEGATECALL\n     *    ExecTypes:\n     *             - EXECTYPE_DEFAULT (revert if not successful)\n     *             - EXECTYPE_TRY\n     *    If a different mode is selected, this function will revert\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\n     * @param executionCalldata The encoded execution call data\n     */\n    function executeFromExecutor(\n        ModeCode mode,\n        bytes memory executionCalldata\n    )\n        external\n        returns (bytes[] memory returnDatas);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      Manage Modules                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * Installs a 7579 Module of a certain type on the smart account\n     * @dev The module has to be initialized from msg.sender == SafeProxy, we thus use a\n     *    delegatecall to DCUtil, which calls the onInstall/onUninstall function on the ERC7579\n     *    module and emits the ModuleInstall/ModuleUnintall events\n     * @dev AccessControl: only Self of Entrypoint can install modules\n     * @dev If the safe set a registry, ERC7484 registry will be queried before installing\n     * @dev If a global hook and/or selector hook is set, it will be called\n     * @param moduleType the module type ID according the ERC-7579 spec\n     *                   Note: MULTITYPE_MODULE (uint(0)) is a special type to install a module with\n     *                         multiple types\n     * @param module the module address\n     * @param initData arbitrary data that may be required on the module during `onInstall`\n     * initialization.\n     */\n    function installModule(uint256 moduleType, address module, bytes memory initData) external;\n\n    /**\n     * Uninstalls a Module of a certain type on the smart account.\n     * @dev The module has to be initialized from msg.sender == SafeProxy, we thus use a\n     *    delegatecall to DCUtil, which calls the onInstall/onUninstall function on the ERC7579\n     *    module and emits the ModuleInstall/ModuleUnintall events\n     * @dev AccessControl: only Self of Entrypoint can install modules\n     * @dev If a global hook and/or selector hook is set, it will be called\n     * @param moduleType the module type ID according the ERC-7579 spec\n     * @param module the module address\n     * @param deInitData arbitrary data that may be required on the module during `onUninstall`\n     * de-initialization.\n     */\n    function uninstallModule(\n        uint256 moduleType,\n        address module,\n        bytes memory deInitData\n    )\n        external;\n\n    /**\n     * Function to check if the account has a certain module installed\n     * @param moduleType the module type ID according the ERC-7579 spec\n     *      Note: keep in mind that some contracts can be multiple module types at the same time. It\n     *            thus may be necessary to query multiple module types\n     * @param module the module address\n     * @param additionalContext additional context data that the smart account may interpret to\n     *                          identifiy conditions under which the module is installed.\n     *                          usually this is not necessary, but for some special hooks that\n     *                          are stored in mappings, this param might be needed\n     */\n    function isModuleInstalled(\n        uint256 moduleType,\n        address module,\n        bytes memory additionalContext\n    )\n        external\n        view\n        returns (bool);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   Initialize Safe7579                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * This function can be called by the Launchpad.initSafe7579() or by already existing Safes that\n     * want to use Safe7579\n     * if this is called by the Launchpad, it is expected that launchpadValidators() was called\n     * previously, and the param validators is empty\n     * @param validators validator modules and initData\n     * @param executors executor modules and initData\n     * @param executors executor modules and initData\n     * @param fallbacks fallback modules and initData\n     * @param hooks hook module and initData\n     * @param registryInit (OPTIONAL) registry, attesters and threshold for IERC7484 Registry\n     *                    If not provided, the registry will be set to the zero address, and no\n     *                    registry checks will be performed\n     */\n    function initializeAccount(\n        ModuleInit[] memory validators,\n        ModuleInit[] memory executors,\n        ModuleInit[] memory fallbacks,\n        ModuleInit[] memory hooks,\n        RegistryInit memory registryInit\n    )\n        external;\n\n    /**\n     * This function is intended to be called by Launchpad.validateUserOp()\n     * @dev it will initialize the SentinelList4337 list for validators, and sstore all\n     * validators\n     * @dev Since this function has to be 4337 compliant (storage access), only validator storage is  acccess\n     * @dev Note: this function DOES NOT call onInstall() on the validator modules or emit\n     * ModuleInstalled events. this has to be done by the launchpad\n     */\n    function initializeAccountWithValidators(ModuleInit[] memory validators) external;\n\n    /**\n     * Configure the Safe7579 with a IERC7484 registry\n     * @param registry IERC7484 registry\n     * @param attesters list of attesters\n     * @param threshold number of attesters required\n     */\n    function setRegistry(IERC7484 registry, address[] memory attesters, uint8 threshold) external;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   Query Account Details                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n    function getValidatorsPaginated(\n        address cursor,\n        uint256 pageSize\n    )\n        external\n        view\n        returns (address[] memory array, address next);\n\n    /**\n     * Get the current active global hook\n     */\n    function getActiveHook() external view returns (address hook);\n\n    /**\n     * Get the current active selector hook\n     */\n    function getActiveHook(bytes4 selector) external view returns (address hook);\n\n    function getExecutorsPaginated(\n        address cursor,\n        uint256 size\n    )\n        external\n        view\n        returns (address[] memory array, address next);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        Query Misc                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * Safe7579 is using validator selection encoding in the userop nonce.\n     * to make it easier for SDKs / devs to integrate, this function can be\n     * called to get the next nonce for a specific validator\n     * @param safe address of safe account\n     * @param validator ERC7579 validator to encode\n     */\n    function getNonce(address safe, address validator) external view returns (uint256 nonce);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       Custom Errors                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n    error InvalidModule(address module);\n    error InvalidModuleType(address module, uint256 moduleType);\n\n    // fallback handlers\n    error InvalidInput();\n    error InvalidCallType(CallType callType);\n    error NoFallbackHandler(bytes4 msgSig);\n    error InvalidFallbackHandler(bytes4 msgSig);\n    error FallbackInstalled(bytes4 msgSig);\n\n    // Hooks\n    error HookAlreadyInstalled(address currentHook);\n    error InvalidHookType();\n\n    // Registry Adapter\n    event ERC7484RegistryConfigured(address indexed smartAccount, IERC7484 indexed registry);\n}\n"},"node_modules/@rhinestone/modulekit/src/module-bases/utils/ERC7579Constants.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\nuint256 constant MODULE_TYPE_VALIDATOR = 1;\nuint256 constant MODULE_TYPE_EXECUTOR = 2;\nuint256 constant MODULE_TYPE_FALLBACK = 3;\nuint256 constant MODULE_TYPE_HOOK = 4;\nuint256 constant MODULE_TYPE_POLICY = 5;\nuint256 constant MODULE_TYPE_SIGNER = 6;\nuint256 constant MODULE_TYPE_STATELESS_VALIDATOR = 7;\n"},"node_modules/@rhinestone/modulekit/src/module-bases/interfaces/IStatelessValidator.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\ninterface IStatelessValidator {\n    function validateSignatureWithData(\n        bytes32 hash,\n        bytes calldata signature,\n        bytes calldata data\n    )\n        external\n        view\n        returns (bool);\n}\n"},"node_modules/@rhinestone/modulekit/src/module-bases/interfaces/IERC7484.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC7484 {\n    event NewTrustedAttesters();\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*          Check with Registry internal attesters            */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function check(address module) external view;\n\n    function checkForAccount(address smartAccount, address module) external view;\n\n    function check(address module, uint256 moduleType) external view;\n\n    function checkForAccount(\n        address smartAccount,\n        address module,\n        uint256 moduleType\n    )\n        external\n        view;\n\n    /**\n     * Allows Smart Accounts - the end users of the registry - to appoint\n     * one or many attesters as trusted.\n     * @dev this function reverts, if address(0), or duplicates are provided in attesters[]\n     *\n     * @param threshold The minimum number of attestations required for a module\n     *                  to be considered secure.\n     * @param attesters The addresses of the attesters to be trusted.\n     */\n    function trustAttesters(uint8 threshold, address[] calldata attesters) external;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              Check with external attester(s)               */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function check(address module, address[] calldata attesters, uint256 threshold) external view;\n\n    function check(\n        address module,\n        uint256 moduleType,\n        address[] calldata attesters,\n        uint256 threshold\n    )\n        external\n        view;\n}\n"},"node_modules/@rhinestone/modulekit/src/module-bases/interfaces/IPolicy.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.0 <0.9.0;\n\n// solhint-disable no-unused-import\nimport { PackedUserOperation, _packValidationData } from \"../../external/ERC4337.sol\";\nimport {\n    IModule as IERC7579Module,\n    VALIDATION_SUCCESS,\n    VALIDATION_FAILED\n} from \"../../accounts/common/interfaces/IERC7579Module.sol\";\nimport { IERC165 } from \"forge-std/interfaces/IERC165.sol\";\n\ntype ConfigId is bytes32;\n\n/**\n * IPolicy are external contracts that enforce policies / permission on 4337/7579 executions\n * Since it's not the account calling into this contract, and check functions are called during the\n * ERC4337 validation\n * phase, IPolicy implementations MUST follow ERC4337 storage and opcode restrictions\n * A recommend storage layout to store policy related data:\n *      mapping(id   =>   msg.sender   =>   userOp.sender(account) => state)\n *                        ^ smartSession    ^ smart account (associated storage)\n */\ninterface IPolicy is IERC165, IERC7579Module {\n    function isInitialized(address account, ConfigId configId) external view returns (bool);\n    function isInitialized(\n        address account,\n        address mulitplexer,\n        ConfigId configId\n    )\n        external\n        view\n        returns (bool);\n\n    /**\n     * This function may be called by the multiplexer (SmartSessions) without deinitializing first.\n     * Policies MUST overwrite the current state when this happens\n     */\n    function initializeWithMultiplexer(\n        address account,\n        ConfigId configId,\n        bytes calldata initData\n    )\n        external;\n}\n\n/**\n * IUserOpPolicy is a policy that enforces restrictions on user operations. It is called during the\n * validation phase\n * of the ERC4337 execution.\n * Use this policy to enforce restrictions on user operations (userOp.gas, Time based restrictions).\n * The checkUserOpPolicy function should return a uint256 value that represents the policy's\n * decision.\n * The policy's decision should be one of the following:\n * - VALIDATION_SUCCESS: The user operation is allowed.\n * - VALIDATION_FAILED: The user operation is not allowed.\n */\ninterface IUserOpPolicy is IPolicy {\n    function checkUserOpPolicy(\n        ConfigId id,\n        PackedUserOperation calldata userOp\n    )\n        external\n        returns (uint256);\n}\n\n/**\n * IActionPolicy is a policy that enforces restrictions on actions. It is called during the\n * validation phase\n * of the ERC4337 execution.\n * ERC7579 accounts natively support batched executions. So in one userOp, multiple actions can be\n * executed.\n * SmartSession will destruct the execution batch, and call the policy for each action, if the\n * policy is installed for\n * the actionId for the account.\n * Use this policy to enforce restrictions on individual actions (i.e. transfers, approvals, etc).\n * The checkAction function should return a uint256 value that represents the policy's decision.\n * The policy's decision should be one of the following:\n * - VALIDATION_SUCCESS: The action is allowed.\n * - VALIDATION_FAILED: The action is not allowed.\n */\ninterface IActionPolicy is IPolicy {\n    function checkAction(\n        ConfigId id,\n        address account,\n        address target,\n        uint256 value,\n        bytes calldata data\n    )\n        external\n        returns (uint256);\n}\n\n/**\n * I1271Policy is a policy that enforces restrictions on 1271 signed actions. It is called during an\n * ERC1271 signature\n * validation\n */\ninterface I1271Policy is IPolicy {\n    // request sender is probably protocol, so can introduce policies based on it.\n    function check1271SignedAction(\n        ConfigId id,\n        address requestSender,\n        address account,\n        bytes32 hash,\n        bytes calldata signature\n    )\n        external\n        view\n        returns (bool);\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/core/EntryPoint.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.23;\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n\nimport \"../interfaces/IAccount.sol\";\nimport \"../interfaces/IAccountExecute.sol\";\nimport \"../interfaces/IPaymaster.sol\";\nimport \"../interfaces/IEntryPoint.sol\";\n\nimport \"../utils/Exec.sol\";\nimport \"./StakeManager.sol\";\nimport \"./SenderCreator.sol\";\nimport \"./Helpers.sol\";\nimport \"./NonceManager.sol\";\nimport \"./UserOperationLib.sol\";\nimport \"./GasDebug.sol\";\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/*\n * Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\n * Only one instance required on each chain.\n */\n\n/// @custom:security-contact https://bounty.ethereum.org\ncontract EntryPoint is IEntryPoint, StakeManager, NonceManager, ReentrancyGuard, ERC165, GasDebug {\n    using UserOperationLib for PackedUserOperation;\n\n    SenderCreator private immutable _senderCreator = new SenderCreator();\n\n    function senderCreator() internal view virtual returns (SenderCreator) {\n        return _senderCreator;\n    }\n\n    //compensate for innerHandleOps' emit message and deposit refund.\n    // allow some slack for future gas price changes.\n    uint256 private constant INNER_GAS_OVERHEAD = 10000;\n\n    // Marker for inner call revert on out of gas\n    bytes32 private constant INNER_OUT_OF_GAS = hex\"deaddead\";\n    bytes32 private constant INNER_REVERT_LOW_PREFUND = hex\"deadaa51\";\n\n    uint256 private constant REVERT_REASON_MAX_LEN = 2048;\n    uint256 private constant PENALTY_PERCENT = 10;\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        // note: solidity \"type(IEntryPoint).interfaceId\" is without inherited methods but we want to check everything\n        return interfaceId\n            == (type(IEntryPoint).interfaceId ^ type(IStakeManager).interfaceId ^ type(INonceManager).interfaceId)\n            || interfaceId == type(IEntryPoint).interfaceId || interfaceId == type(IStakeManager).interfaceId\n            || interfaceId == type(INonceManager).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * Compensate the caller's beneficiary address with the collected fees of all UserOperations.\n     * @param beneficiary - The address to receive the fees.\n     * @param amount      - Amount to transfer.\n     */\n    function _compensate(address payable beneficiary, uint256 amount) internal {\n        require(beneficiary != address(0), \"AA90 invalid beneficiary\");\n        (bool success,) = beneficiary.call{value: amount}(\"\");\n        require(success, \"AA91 failed send to beneficiary\");\n    }\n\n    /**\n     * Execute a user operation.\n     * @param opIndex    - Index into the opInfo array.\n     * @param userOp     - The userOp to execute.\n     * @param opInfo     - The opInfo filled by validatePrepayment for this userOp.\n     * @return collected - The total amount this userOp paid.\n     */\n    function _executeUserOp(uint256 opIndex, PackedUserOperation calldata userOp, UserOpInfo memory opInfo)\n        internal\n        returns (uint256 collected)\n    {\n        uint256 preGas = gasleft();\n        bytes memory context = getMemoryBytesFromOffset(opInfo.contextOffset);\n        bool success;\n        {\n            uint256 saveFreePtr;\n            assembly (\"memory-safe\") {\n                saveFreePtr := mload(0x40)\n            }\n            bytes calldata callData = userOp.callData;\n            bytes memory innerCall;\n            bytes4 methodSig;\n            assembly {\n                let len := callData.length\n                if gt(len, 3) { methodSig := calldataload(callData.offset) }\n            }\n            if (methodSig == IAccountExecute.executeUserOp.selector) {\n                bytes memory executeUserOp = abi.encodeCall(IAccountExecute.executeUserOp, (userOp, opInfo.userOpHash));\n                innerCall = abi.encodeCall(this.innerHandleOp, (executeUserOp, opInfo, context));\n            } else {\n                innerCall = abi.encodeCall(this.innerHandleOp, (callData, opInfo, context));\n            }\n            assembly (\"memory-safe\") {\n                success := call(gas(), address(), 0, add(innerCall, 0x20), mload(innerCall), 0, 32)\n                collected := mload(0)\n                mstore(0x40, saveFreePtr)\n            }\n        }\n        if (!success) {\n            bytes32 innerRevertCode;\n            assembly (\"memory-safe\") {\n                let len := returndatasize()\n                if eq(32, len) {\n                    returndatacopy(0, 0, 32)\n                    innerRevertCode := mload(0)\n                }\n            }\n            if (innerRevertCode == INNER_OUT_OF_GAS) {\n                // handleOps was called with gas limit too low. abort entire bundle.\n                //can only be caused by bundler (leaving not enough gas for inner call)\n                revert FailedOp(opIndex, \"AA95 out of gas\");\n            } else if (innerRevertCode == INNER_REVERT_LOW_PREFUND) {\n                // innerCall reverted on prefund too low. treat entire prefund as \"gas cost\"\n                uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\n                uint256 actualGasCost = opInfo.prefund;\n                emitPrefundTooLow(opInfo);\n                emitUserOperationEvent(opInfo, false, actualGasCost, actualGas);\n                collected = actualGasCost;\n            } else {\n                emit PostOpRevertReason(\n                    opInfo.userOpHash,\n                    opInfo.mUserOp.sender,\n                    opInfo.mUserOp.nonce,\n                    Exec.getReturnData(REVERT_REASON_MAX_LEN)\n                );\n\n                uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\n                collected = _postExecution(IPaymaster.PostOpMode.postOpReverted, opInfo, context, actualGas);\n            }\n        }\n    }\n\n    function emitUserOperationEvent(UserOpInfo memory opInfo, bool success, uint256 actualGasCost, uint256 actualGas)\n        internal\n        virtual\n    {\n        emit UserOperationEvent(\n            opInfo.userOpHash,\n            opInfo.mUserOp.sender,\n            opInfo.mUserOp.paymaster,\n            opInfo.mUserOp.nonce,\n            success,\n            actualGasCost,\n            actualGas\n        );\n    }\n\n    function emitPrefundTooLow(UserOpInfo memory opInfo) internal virtual {\n        emit UserOperationPrefundTooLow(opInfo.userOpHash, opInfo.mUserOp.sender, opInfo.mUserOp.nonce);\n    }\n\n    /// @inheritdoc IEntryPoint\n    function handleOps(PackedUserOperation[] calldata ops, address payable beneficiary) public nonReentrant {\n        uint256 opslen = ops.length;\n        UserOpInfo[] memory opInfos = new UserOpInfo[](opslen);\n\n        unchecked {\n            for (uint256 i = 0; i < opslen; i++) {\n                UserOpInfo memory opInfo = opInfos[i];\n                (uint256 validationData, uint256 pmValidationData) = _validatePrepayment(i, ops[i], opInfo);\n                _validateAccountAndPaymasterValidationData(i, validationData, pmValidationData, address(0));\n            }\n\n            uint256 collected = 0;\n            emit BeforeExecution();\n\n            for (uint256 i = 0; i < opslen; i++) {\n                collected += _executeUserOp(i, ops[i], opInfos[i]);\n            }\n\n            _compensate(beneficiary, collected);\n        }\n    }\n\n    /// @inheritdoc IEntryPoint\n    function handleAggregatedOps(UserOpsPerAggregator[] calldata opsPerAggregator, address payable beneficiary)\n        public\n        nonReentrant\n    {\n        uint256 opasLen = opsPerAggregator.length;\n        uint256 totalOps = 0;\n        for (uint256 i = 0; i < opasLen; i++) {\n            UserOpsPerAggregator calldata opa = opsPerAggregator[i];\n            PackedUserOperation[] calldata ops = opa.userOps;\n            IAggregator aggregator = opa.aggregator;\n\n            //address(1) is special marker of \"signature error\"\n            require(address(aggregator) != address(1), \"AA96 invalid aggregator\");\n\n            if (address(aggregator) != address(0)) {\n                // solhint-disable-next-line no-empty-blocks\n                try aggregator.validateSignatures(ops, opa.signature) {}\n                catch {\n                    revert SignatureValidationFailed(address(aggregator));\n                }\n            }\n\n            totalOps += ops.length;\n        }\n\n        UserOpInfo[] memory opInfos = new UserOpInfo[](totalOps);\n\n        uint256 opIndex = 0;\n        for (uint256 a = 0; a < opasLen; a++) {\n            UserOpsPerAggregator calldata opa = opsPerAggregator[a];\n            PackedUserOperation[] calldata ops = opa.userOps;\n            IAggregator aggregator = opa.aggregator;\n\n            uint256 opslen = ops.length;\n            for (uint256 i = 0; i < opslen; i++) {\n                UserOpInfo memory opInfo = opInfos[opIndex];\n                (uint256 validationData, uint256 paymasterValidationData) = _validatePrepayment(opIndex, ops[i], opInfo);\n                _validateAccountAndPaymasterValidationData(\n                    i, validationData, paymasterValidationData, address(aggregator)\n                );\n                opIndex++;\n            }\n        }\n\n        emit BeforeExecution();\n\n        uint256 collected = 0;\n        opIndex = 0;\n        for (uint256 a = 0; a < opasLen; a++) {\n            UserOpsPerAggregator calldata opa = opsPerAggregator[a];\n            emit SignatureAggregatorChanged(address(opa.aggregator));\n            PackedUserOperation[] calldata ops = opa.userOps;\n            uint256 opslen = ops.length;\n\n            for (uint256 i = 0; i < opslen; i++) {\n                collected += _executeUserOp(opIndex, ops[i], opInfos[opIndex]);\n                opIndex++;\n            }\n        }\n        emit SignatureAggregatorChanged(address(0));\n\n        _compensate(beneficiary, collected);\n    }\n\n    /**\n     * A memory copy of UserOp static fields only.\n     * Excluding: callData, initCode and signature. Replacing paymasterAndData with paymaster.\n     */\n    struct MemoryUserOp {\n        address sender;\n        uint256 nonce;\n        uint256 verificationGasLimit;\n        uint256 callGasLimit;\n        uint256 paymasterVerificationGasLimit;\n        uint256 paymasterPostOpGasLimit;\n        uint256 preVerificationGas;\n        address paymaster;\n        uint256 maxFeePerGas;\n        uint256 maxPriorityFeePerGas;\n    }\n\n    struct UserOpInfo {\n        MemoryUserOp mUserOp;\n        bytes32 userOpHash;\n        uint256 prefund;\n        uint256 contextOffset;\n        uint256 preOpGas;\n    }\n\n    /**\n     * Inner function to handle a UserOperation.\n     * Must be declared \"external\" to open a call context, but it can only be called by handleOps.\n     * @param callData - The callData to execute.\n     * @param opInfo   - The UserOpInfo struct.\n     * @param context  - The context bytes.\n     * @return actualGasCost - the actual cost in eth this UserOperation paid for gas\n     */\n    function innerHandleOp(bytes memory callData, UserOpInfo memory opInfo, bytes calldata context)\n        external\n        returns (uint256 actualGasCost)\n    {\n        uint256 preGas = gasleft();\n        require(msg.sender == address(this), \"AA92 internal call only\");\n        MemoryUserOp memory mUserOp = opInfo.mUserOp;\n\n        uint256 callGasLimit = mUserOp.callGasLimit;\n        unchecked {\n            // handleOps was called with gas limit too low. abort entire bundle.\n            if (gasleft() * 63 / 64 < callGasLimit + mUserOp.paymasterPostOpGasLimit + INNER_GAS_OVERHEAD) {\n                assembly (\"memory-safe\") {\n                    mstore(0, INNER_OUT_OF_GAS)\n                    revert(0, 32)\n                }\n            }\n        }\n\n        IPaymaster.PostOpMode mode = IPaymaster.PostOpMode.opSucceeded;\n        if (callData.length > 0) {\n            uint256 _execGas = gasleft();\n            bool success = Exec.call(mUserOp.sender, 0, callData, callGasLimit);\n            setGasConsumed(mUserOp.sender, 2, _execGas - gasleft());\n            if (!success) {\n                bytes memory result = Exec.getReturnData(REVERT_REASON_MAX_LEN);\n                if (result.length > 0) {\n                    emit UserOperationRevertReason(opInfo.userOpHash, mUserOp.sender, mUserOp.nonce, result);\n                }\n                mode = IPaymaster.PostOpMode.opReverted;\n            }\n        }\n\n        unchecked {\n            uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\n            return _postExecution(mode, opInfo, context, actualGas);\n        }\n    }\n\n    /// @inheritdoc IEntryPoint\n    function getUserOpHash(PackedUserOperation calldata userOp) public view returns (bytes32) {\n        return keccak256(abi.encode(userOp.hash(), address(this), block.chainid));\n    }\n\n    /**\n     * Copy general fields from userOp into the memory opInfo structure.\n     * @param userOp  - The user operation.\n     * @param mUserOp - The memory user operation.\n     */\n    function _copyUserOpToMemory(PackedUserOperation calldata userOp, MemoryUserOp memory mUserOp) internal pure {\n        mUserOp.sender = userOp.sender;\n        mUserOp.nonce = userOp.nonce;\n        (mUserOp.verificationGasLimit, mUserOp.callGasLimit) = UserOperationLib.unpackUints(userOp.accountGasLimits);\n        mUserOp.preVerificationGas = userOp.preVerificationGas;\n        (mUserOp.maxPriorityFeePerGas, mUserOp.maxFeePerGas) = UserOperationLib.unpackUints(userOp.gasFees);\n        bytes calldata paymasterAndData = userOp.paymasterAndData;\n        if (paymasterAndData.length > 0) {\n            require(paymasterAndData.length >= UserOperationLib.PAYMASTER_DATA_OFFSET, \"AA93 invalid paymasterAndData\");\n            (mUserOp.paymaster, mUserOp.paymasterVerificationGasLimit, mUserOp.paymasterPostOpGasLimit) =\n                UserOperationLib.unpackPaymasterStaticFields(paymasterAndData);\n        } else {\n            mUserOp.paymaster = address(0);\n            mUserOp.paymasterVerificationGasLimit = 0;\n            mUserOp.paymasterPostOpGasLimit = 0;\n        }\n    }\n\n    /**\n     * Get the required prefunded gas fee amount for an operation.\n     * @param mUserOp - The user operation in memory.\n     */\n    function _getRequiredPrefund(MemoryUserOp memory mUserOp) internal pure returns (uint256 requiredPrefund) {\n        unchecked {\n            uint256 requiredGas = mUserOp.verificationGasLimit + mUserOp.callGasLimit\n                + mUserOp.paymasterVerificationGasLimit + mUserOp.paymasterPostOpGasLimit + mUserOp.preVerificationGas;\n\n            requiredPrefund = requiredGas * mUserOp.maxFeePerGas;\n        }\n    }\n\n    /**\n     * Create sender smart contract account if init code is provided.\n     * @param opIndex  - The operation index.\n     * @param opInfo   - The operation info.\n     * @param initCode - The init code for the smart contract account.\n     */\n    function _createSenderIfNeeded(uint256 opIndex, UserOpInfo memory opInfo, bytes calldata initCode) internal {\n        if (initCode.length != 0) {\n            address sender = opInfo.mUserOp.sender;\n            if (sender.code.length != 0) {\n                revert FailedOp(opIndex, \"AA10 sender already constructed\");\n            }\n            uint256 _creationGas = gasleft();\n            address sender1 = senderCreator().createSender{gas: opInfo.mUserOp.verificationGasLimit}(initCode);\n            setGasConsumed(sender, 0, _creationGas - gasleft());\n            if (sender1 == address(0)) {\n                revert FailedOp(opIndex, \"AA13 initCode failed or OOG\");\n            }\n            if (sender1 != sender) {\n                revert FailedOp(opIndex, \"AA14 initCode must return sender\");\n            }\n            if (sender1.code.length == 0) {\n                revert FailedOp(opIndex, \"AA15 initCode must create sender\");\n            }\n            address factory = address(bytes20(initCode[0:20]));\n            emit AccountDeployed(opInfo.userOpHash, sender, factory, opInfo.mUserOp.paymaster);\n        }\n    }\n\n    /// @inheritdoc IEntryPoint\n    function getSenderAddress(bytes calldata initCode) public {\n        address sender = senderCreator().createSender(initCode);\n        revert SenderAddressResult(sender);\n    }\n\n    /**\n     * Call account.validateUserOp.\n     * Revert (with FailedOp) in case validateUserOp reverts, or account didn't send required prefund.\n     * Decrement account's deposit if needed.\n     * @param opIndex         - The operation index.\n     * @param op              - The user operation.\n     * @param opInfo          - The operation info.\n     * @param requiredPrefund - The required prefund amount.\n     */\n    function _validateAccountPrepayment(\n        uint256 opIndex,\n        PackedUserOperation calldata op,\n        UserOpInfo memory opInfo,\n        uint256 requiredPrefund,\n        uint256 verificationGasLimit\n    ) internal returns (uint256 validationData) {\n        unchecked {\n            MemoryUserOp memory mUserOp = opInfo.mUserOp;\n            address sender = mUserOp.sender;\n            _createSenderIfNeeded(opIndex, opInfo, op.initCode);\n            address paymaster = mUserOp.paymaster;\n            uint256 missingAccountFunds = 0;\n            if (paymaster == address(0)) {\n                uint256 bal = balanceOf(sender);\n                missingAccountFunds = bal > requiredPrefund ? 0 : requiredPrefund - bal;\n            }\n            uint256 _verificationGas = gasleft();\n            try IAccount(sender).validateUserOp{gas: verificationGasLimit}(op, opInfo.userOpHash, missingAccountFunds)\n            returns (uint256 _validationData) {\n                validationData = _validationData;\n                setGasConsumed(sender, 1, _verificationGas - gasleft());\n            } catch {\n                revert FailedOpWithRevert(opIndex, \"AA23 reverted\", Exec.getReturnData(REVERT_REASON_MAX_LEN));\n            }\n            if (paymaster == address(0)) {\n                DepositInfo storage senderInfo = deposits[sender];\n                uint256 deposit = senderInfo.deposit;\n                if (requiredPrefund > deposit) {\n                    revert FailedOp(opIndex, \"AA21 didn't pay prefund\");\n                }\n                senderInfo.deposit = deposit - requiredPrefund;\n            }\n        }\n    }\n\n    /**\n     * In case the request has a paymaster:\n     *  - Validate paymaster has enough deposit.\n     *  - Call paymaster.validatePaymasterUserOp.\n     *  - Revert with proper FailedOp in case paymaster reverts.\n     *  - Decrement paymaster's deposit.\n     * @param opIndex                            - The operation index.\n     * @param op                                 - The user operation.\n     * @param opInfo                             - The operation info.\n     * @param requiredPreFund                    - The required prefund amount.\n     */\n    function _validatePaymasterPrepayment(\n        uint256 opIndex,\n        PackedUserOperation calldata op,\n        UserOpInfo memory opInfo,\n        uint256 requiredPreFund\n    ) internal returns (bytes memory context, uint256 validationData) {\n        unchecked {\n            uint256 preGas = gasleft();\n            MemoryUserOp memory mUserOp = opInfo.mUserOp;\n            address paymaster = mUserOp.paymaster;\n            DepositInfo storage paymasterInfo = deposits[paymaster];\n            uint256 deposit = paymasterInfo.deposit;\n            if (deposit < requiredPreFund) {\n                revert FailedOp(opIndex, \"AA31 paymaster deposit too low\");\n            }\n            paymasterInfo.deposit = deposit - requiredPreFund;\n            uint256 pmVerificationGasLimit = mUserOp.paymasterVerificationGasLimit;\n            try IPaymaster(paymaster).validatePaymasterUserOp{gas: pmVerificationGasLimit}(\n                op, opInfo.userOpHash, requiredPreFund\n            ) returns (bytes memory _context, uint256 _validationData) {\n                context = _context;\n                validationData = _validationData;\n            } catch {\n                revert FailedOpWithRevert(opIndex, \"AA33 reverted\", Exec.getReturnData(REVERT_REASON_MAX_LEN));\n            }\n            if (preGas - gasleft() > pmVerificationGasLimit) {\n                revert FailedOp(opIndex, \"AA36 over paymasterVerificationGasLimit\");\n            }\n        }\n    }\n\n    /**\n     * Revert if either account validationData or paymaster validationData is expired.\n     * @param opIndex                 - The operation index.\n     * @param validationData          - The account validationData.\n     * @param paymasterValidationData - The paymaster validationData.\n     * @param expectedAggregator      - The expected aggregator.\n     */\n    function _validateAccountAndPaymasterValidationData(\n        uint256 opIndex,\n        uint256 validationData,\n        uint256 paymasterValidationData,\n        address expectedAggregator\n    ) internal view {\n        (address aggregator, bool outOfTimeRange) = _getValidationData(validationData);\n        if (expectedAggregator != aggregator) {\n            revert FailedOp(opIndex, \"AA24 signature error\");\n        }\n        if (outOfTimeRange) {\n            revert FailedOp(opIndex, \"AA22 expired or not due\");\n        }\n        // pmAggregator is not a real signature aggregator: we don't have logic to handle it as address.\n        // Non-zero address means that the paymaster fails due to some signature check (which is ok only during estimation).\n        address pmAggregator;\n        (pmAggregator, outOfTimeRange) = _getValidationData(paymasterValidationData);\n        if (pmAggregator != address(0)) {\n            revert FailedOp(opIndex, \"AA34 signature error\");\n        }\n        if (outOfTimeRange) {\n            revert FailedOp(opIndex, \"AA32 paymaster expired or not due\");\n        }\n    }\n\n    /**\n     * Parse validationData into its components.\n     * @param validationData - The packed validation data (sigFailed, validAfter, validUntil).\n     * @return aggregator the aggregator of the validationData\n     * @return outOfTimeRange true if current time is outside the time range of this validationData.\n     */\n    function _getValidationData(uint256 validationData)\n        internal\n        view\n        returns (address aggregator, bool outOfTimeRange)\n    {\n        if (validationData == 0) {\n            return (address(0), false);\n        }\n        ValidationData memory data = _parseValidationData(validationData);\n        // solhint-disable-next-line not-rely-on-time\n        outOfTimeRange = block.timestamp > data.validUntil || block.timestamp < data.validAfter;\n        aggregator = data.aggregator;\n    }\n\n    /**\n     * Validate account and paymaster (if defined) and\n     * also make sure total validation doesn't exceed verificationGasLimit.\n     * This method is called off-chain (simulateValidation()) and on-chain (from handleOps)\n     * @param opIndex - The index of this userOp into the \"opInfos\" array.\n     * @param userOp  - The userOp to validate.\n     */\n    function _validatePrepayment(uint256 opIndex, PackedUserOperation calldata userOp, UserOpInfo memory outOpInfo)\n        internal\n        returns (uint256 validationData, uint256 paymasterValidationData)\n    {\n        uint256 preGas = gasleft();\n        MemoryUserOp memory mUserOp = outOpInfo.mUserOp;\n        _copyUserOpToMemory(userOp, mUserOp);\n        outOpInfo.userOpHash = getUserOpHash(userOp);\n\n        // Validate all numeric values in userOp are well below 128 bit, so they can safely be added\n        // and multiplied without causing overflow.\n        uint256 verificationGasLimit = mUserOp.verificationGasLimit;\n        uint256 maxGasValues = mUserOp.preVerificationGas | verificationGasLimit | mUserOp.callGasLimit\n            | mUserOp.paymasterVerificationGasLimit | mUserOp.paymasterPostOpGasLimit | mUserOp.maxFeePerGas\n            | mUserOp.maxPriorityFeePerGas;\n        require(maxGasValues <= type(uint120).max, \"AA94 gas values overflow\");\n\n        uint256 requiredPreFund = _getRequiredPrefund(mUserOp);\n        validationData = _validateAccountPrepayment(opIndex, userOp, outOpInfo, requiredPreFund, verificationGasLimit);\n\n        if (!_validateAndUpdateNonce(mUserOp.sender, mUserOp.nonce)) {\n            revert FailedOp(opIndex, \"AA25 invalid account nonce\");\n        }\n\n        unchecked {\n            if (preGas - gasleft() > verificationGasLimit) {\n                revert FailedOp(opIndex, \"AA26 over verificationGasLimit\");\n            }\n        }\n\n        bytes memory context;\n        if (mUserOp.paymaster != address(0)) {\n            (context, paymasterValidationData) =\n                _validatePaymasterPrepayment(opIndex, userOp, outOpInfo, requiredPreFund);\n        }\n        unchecked {\n            outOpInfo.prefund = requiredPreFund;\n            outOpInfo.contextOffset = getOffsetOfMemoryBytes(context);\n            outOpInfo.preOpGas = preGas - gasleft() + userOp.preVerificationGas;\n        }\n    }\n\n    /**\n     * Process post-operation, called just after the callData is executed.\n     * If a paymaster is defined and its validation returned a non-empty context, its postOp is called.\n     * The excess amount is refunded to the account (or paymaster - if it was used in the request).\n     * @param mode      - Whether is called from innerHandleOp, or outside (postOpReverted).\n     * @param opInfo    - UserOp fields and info collected during validation.\n     * @param context   - The context returned in validatePaymasterUserOp.\n     * @param actualGas - The gas used so far by this user operation.\n     */\n    function _postExecution(\n        IPaymaster.PostOpMode mode,\n        UserOpInfo memory opInfo,\n        bytes memory context,\n        uint256 actualGas\n    ) private returns (uint256 actualGasCost) {\n        uint256 preGas = gasleft();\n        unchecked {\n            address refundAddress;\n            MemoryUserOp memory mUserOp = opInfo.mUserOp;\n            uint256 gasPrice = getUserOpGasPrice(mUserOp);\n\n            address paymaster = mUserOp.paymaster;\n            if (paymaster == address(0)) {\n                refundAddress = mUserOp.sender;\n            } else {\n                refundAddress = paymaster;\n                if (context.length > 0) {\n                    actualGasCost = actualGas * gasPrice;\n                    if (mode != IPaymaster.PostOpMode.postOpReverted) {\n                        try IPaymaster(paymaster).postOp{gas: mUserOp.paymasterPostOpGasLimit}(\n                            mode, context, actualGasCost, gasPrice\n                        ) {\n                            // solhint-disable-next-line no-empty-blocks\n                        } catch {\n                            bytes memory reason = Exec.getReturnData(REVERT_REASON_MAX_LEN);\n                            revert PostOpReverted(reason);\n                        }\n                    }\n                }\n            }\n            actualGas += preGas - gasleft();\n\n            // Calculating a penalty for unused execution gas\n            {\n                uint256 executionGasLimit = mUserOp.callGasLimit + mUserOp.paymasterPostOpGasLimit;\n                uint256 executionGasUsed = actualGas - opInfo.preOpGas;\n                // this check is required for the gas used within EntryPoint and not covered by explicit gas limits\n                if (executionGasLimit > executionGasUsed) {\n                    uint256 unusedGas = executionGasLimit - executionGasUsed;\n                    uint256 unusedGasPenalty = (unusedGas * PENALTY_PERCENT) / 100;\n                    actualGas += unusedGasPenalty;\n                }\n            }\n\n            actualGasCost = actualGas * gasPrice;\n            uint256 prefund = opInfo.prefund;\n            if (prefund < actualGasCost) {\n                if (mode == IPaymaster.PostOpMode.postOpReverted) {\n                    actualGasCost = prefund;\n                    emitPrefundTooLow(opInfo);\n                    emitUserOperationEvent(opInfo, false, actualGasCost, actualGas);\n                } else {\n                    assembly (\"memory-safe\") {\n                        mstore(0, INNER_REVERT_LOW_PREFUND)\n                        revert(0, 32)\n                    }\n                }\n            } else {\n                uint256 refund = prefund - actualGasCost;\n                _incrementDeposit(refundAddress, refund);\n                bool success = mode == IPaymaster.PostOpMode.opSucceeded;\n                emitUserOperationEvent(opInfo, success, actualGasCost, actualGas);\n            }\n        } // unchecked\n    }\n\n    /**\n     * The gas price this UserOp agrees to pay.\n     * Relayer/block builder might submit the TX with higher priorityFee, but the user should not.\n     * @param mUserOp - The userOp to get the gas price from.\n     */\n    function getUserOpGasPrice(MemoryUserOp memory mUserOp) internal view returns (uint256) {\n        unchecked {\n            uint256 maxFeePerGas = mUserOp.maxFeePerGas;\n            uint256 maxPriorityFeePerGas = mUserOp.maxPriorityFeePerGas;\n            if (maxFeePerGas == maxPriorityFeePerGas) {\n                //legacy mode (for networks that don't support basefee opcode)\n                return maxFeePerGas;\n            }\n            return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\n        }\n    }\n\n    /**\n     * The offset of the given bytes in memory.\n     * @param data - The bytes to get the offset of.\n     */\n    function getOffsetOfMemoryBytes(bytes memory data) internal pure returns (uint256 offset) {\n        assembly {\n            offset := data\n        }\n    }\n\n    /**\n     * The bytes in memory at the given offset.\n     * @param offset - The offset to get the bytes from.\n     */\n    function getMemoryBytesFromOffset(uint256 offset) internal pure returns (bytes memory data) {\n        assembly (\"memory-safe\") {\n            data := offset\n        }\n    }\n\n    /// @inheritdoc IEntryPoint\n    function delegateAndRevert(address target, bytes calldata data) external {\n        (bool success, bytes memory ret) = target.delegatecall(data);\n        revert DelegateAndRevert(success, ret);\n    }\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/interfaces/IAggregator.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./PackedUserOperation.sol\";\n\n/**\n * Aggregated Signatures validator.\n */\ninterface IAggregator {\n    /**\n     * Validate aggregated signature.\n     * Revert if the aggregated signature does not match the given list of operations.\n     * @param userOps   - Array of UserOperations to validate the signature for.\n     * @param signature - The aggregated signature.\n     */\n    function validateSignatures(\n        PackedUserOperation[] calldata userOps,\n        bytes calldata signature\n    ) external view;\n\n    /**\n     * Validate signature of a single userOp.\n     * This method should be called by bundler after EntryPointSimulation.simulateValidation() returns\n     * the aggregator this account uses.\n     * First it validates the signature over the userOp. Then it returns data to be used when creating the handleOps.\n     * @param userOp        - The userOperation received from the user.\n     * @return sigForUserOp - The value to put into the signature field of the userOp when calling handleOps.\n     *                        (usually empty, unless account and aggregator support some kind of \"multisig\".\n     */\n    function validateUserOpSignature(\n        PackedUserOperation calldata userOp\n    ) external view returns (bytes memory sigForUserOp);\n\n    /**\n     * Aggregate multiple signatures into a single value.\n     * This method is called off-chain to calculate the signature to pass with handleOps()\n     * bundler MAY use optimized custom code perform this aggregation.\n     * @param userOps              - Array of UserOperations to collect the signatures from.\n     * @return aggregatedSignature - The aggregated signature.\n     */\n    function aggregateSignatures(\n        PackedUserOperation[] calldata userOps\n    ) external view returns (bytes memory aggregatedSignature);\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/interfaces/INonceManager.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\ninterface INonceManager {\n\n    /**\n     * Return the next nonce for this sender.\n     * Within a given key, the nonce values are sequenced (starting with zero, and incremented by one on each userop)\n     * But UserOp with different keys can come with arbitrary order.\n     *\n     * @param sender the account address\n     * @param key the high 192 bit of the nonce\n     * @return nonce a full nonce to pass for next UserOp with this sender.\n     */\n    function getNonce(address sender, uint192 key)\n    external view returns (uint256 nonce);\n\n    /**\n     * Manually increment the nonce of the sender.\n     * This method is exposed just for completeness..\n     * Account does NOT need to call it, neither during validation, nor elsewhere,\n     * as the EntryPoint will update the nonce regardless.\n     * Possible use-case is call it with various keys to \"initialize\" their nonces to one, so that future\n     * UserOperations will not pay extra for the first transaction with a given key.\n     */\n    function incrementNonce(uint192 key) external;\n}\n"},"node_modules/@rhinestone/modulekit/src/accounts/common/interfaces/IERC4337Account.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.23 <0.9.0;\n\n// Types\nimport { PackedUserOperation } from\n    \"@ERC4337/account-abstraction/contracts/core/UserOperationLib.sol\";\n\ninterface IERC4337Account {\n    /**\n     * Validate user's signature and nonce\n     * the entryPoint will make the call to the recipient only if this validation call returns\n     * successfully.\n     * signature failure should be reported by returning SIG_VALIDATION_FAILED (1).\n     * This allows making a \"simulation call\" without a valid signature\n     * Other failures (e.g. nonce mismatch, or invalid signature format) should still revert to\n     * signal failure.\n     *\n     * @dev Must validate caller is the entryPoint.\n     *      Must validate the signature and nonce\n     * @param userOp              - The operation that is about to be executed.\n     * @param userOpHash          - Hash of the user's request data. can be used as the basis for\n     * signature.\n     * @param missingAccountFunds - Missing funds on the account's deposit in the entrypoint.\n     *                              This is the minimum amount to transfer to the sender(entryPoint)\n     * to be\n     *                              able to make the call. The excess is left as a deposit in the\n     * entrypoint\n     *                              for future calls. Can be withdrawn anytime using\n     * \"entryPoint.withdrawTo()\".\n     *                              In case there is a paymaster in the request (or the current\n     * deposit is high\n     *                              enough), this value will be zero.\n     * @return validationData       - Packaged ValidationData structure. use `_packValidationData`\n     * and\n     *                              `_unpackValidationData` to encode and decode.\n     *                              <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark\n     * signature failure,\n     *                                 otherwise, an address of an \"authorizer\" contract.\n     *                              <6-byte> validUntil - Last timestamp this operation is valid. 0\n     * for \"indefinite\"\n     *                              <6-byte> validAfter - First timestamp this operation is valid\n     *                                                    If an account doesn't use time-range, it\n     * is enough to\n     *                                                    return SIG_VALIDATION_FAILED value (1) for\n     * signature failure.\n     *                              Note that the validation code cannot use block.timestamp (or\n     * block.number) directly.\n     */\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    )\n        external\n        payable\n        returns (uint256 validationData);\n\n    /**\n     * Account may implement this execute method.\n     * passing this methodSig at the beginning of callData will cause the entryPoint to pass the\n     * full UserOp (and hash)\n     * to the account.\n     * The account should skip the methodSig, and use the callData (and optionally, other UserOp\n     * fields)\n     *\n     * @param userOp              - The operation that was just validated.\n     * @param userOpHash          - Hash of the user's request data.\n     */\n    function executeUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash\n    )\n        external\n        payable;\n}\n"},"node_modules/@rhinestone/modulekit/src/accounts/kernel/lib/ExecLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.23 <0.9.0;\n\n// Types\nimport { ExecMode, CallType, ExecType, ExecModeSelector, ExecModePayload } from \"../types/Types.sol\";\nimport {\n    CALLTYPE_SINGLE,\n    CALLTYPE_BATCH,\n    EXECTYPE_DEFAULT,\n    EXEC_MODE_DEFAULT,\n    EXECTYPE_TRY,\n    CALLTYPE_DELEGATECALL\n} from \"../types/Constants.sol\";\nimport { Execution } from \"../types/Structs.sol\";\n\n/**\n * @dev ExecLib is a helper library for execution\n */\nlibrary ExecLib {\n    error ExecutionFailed();\n\n    event TryExecuteUnsuccessful(uint256 batchExecutionindex, bytes result);\n\n    function execute(\n        ExecMode execMode,\n        bytes calldata executionCalldata\n    )\n        internal\n        returns (bytes[] memory returnData)\n    {\n        (CallType callType, ExecType execType,,) = decode(execMode);\n\n        // check if calltype is batch or single\n        if (callType == CALLTYPE_BATCH) {\n            // destructure executionCallData according to batched exec\n            Execution[] calldata executions = decodeBatch(executionCalldata);\n            // check if execType is revert or try\n            if (execType == EXECTYPE_DEFAULT) returnData = execute(executions);\n            else if (execType == EXECTYPE_TRY) returnData = tryExecute(executions);\n            else revert(\"Unsupported\");\n        } else if (callType == CALLTYPE_SINGLE) {\n            // destructure executionCallData according to single exec\n            (address target, uint256 value, bytes calldata callData) =\n                decodeSingle(executionCalldata);\n            returnData = new bytes[](1);\n            bool success;\n            // check if execType is revert or try\n            if (execType == EXECTYPE_DEFAULT) {\n                returnData[0] = execute(target, value, callData);\n            } else if (execType == EXECTYPE_TRY) {\n                (success, returnData[0]) = tryExecute(target, value, callData);\n                if (!success) emit TryExecuteUnsuccessful(0, returnData[0]);\n            } else {\n                revert(\"Unsupported\");\n            }\n        } else if (callType == CALLTYPE_DELEGATECALL) {\n            returnData = new bytes[](1);\n            address delegate = address(bytes20(executionCalldata[0:20]));\n            bytes calldata callData = executionCalldata[20:];\n            bool success;\n            (success, returnData[0]) = executeDelegatecall(delegate, callData);\n            if (execType == EXECTYPE_TRY) {\n                if (!success) emit TryExecuteUnsuccessful(0, returnData[0]);\n            } else if (execType == EXECTYPE_DEFAULT) {\n                if (!success) revert(\"Delegatecall failed\");\n            } else {\n                revert(\"Unsupported\");\n            }\n        } else {\n            revert(\"Unsupported\");\n        }\n    }\n\n    function execute(Execution[] calldata executions) internal returns (bytes[] memory result) {\n        uint256 length = executions.length;\n        result = new bytes[](length);\n\n        for (uint256 i; i < length; i++) {\n            Execution calldata _exec = executions[i];\n            result[i] = execute(_exec.target, _exec.value, _exec.callData);\n        }\n    }\n\n    function tryExecute(Execution[] calldata executions) internal returns (bytes[] memory result) {\n        uint256 length = executions.length;\n        result = new bytes[](length);\n\n        for (uint256 i; i < length; i++) {\n            Execution calldata _exec = executions[i];\n            bool success;\n            (success, result[i]) = tryExecute(_exec.target, _exec.value, _exec.callData);\n            if (!success) emit TryExecuteUnsuccessful(i, result[i]);\n        }\n    }\n\n    function execute(\n        address target,\n        uint256 value,\n        bytes calldata callData\n    )\n        internal\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            calldatacopy(result, callData.offset, callData.length)\n            if iszero(call(gas(), target, value, result, callData.length, codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(result, 0x00, returndatasize())\n                revert(result, returndatasize())\n            }\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }\n\n    function tryExecute(\n        address target,\n        uint256 value,\n        bytes calldata callData\n    )\n        internal\n        returns (bool success, bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            calldatacopy(result, callData.offset, callData.length)\n            success := call(gas(), target, value, result, callData.length, codesize(), 0x00)\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }\n\n    /// @dev Execute a delegatecall with `delegate` on this account.\n    function executeDelegatecall(\n        address delegate,\n        bytes calldata callData\n    )\n        internal\n        returns (bool success, bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            calldatacopy(result, callData.offset, callData.length)\n            // Forwards the `data` to `delegate` via delegatecall.\n            success := delegatecall(gas(), delegate, result, callData.length, codesize(), 0x00)\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }\n\n    function decode(ExecMode mode)\n        internal\n        pure\n        returns (\n            CallType _calltype,\n            ExecType _execType,\n            ExecModeSelector _modeSelector,\n            ExecModePayload _modePayload\n        )\n    {\n        assembly {\n            _calltype := mode\n            _execType := shl(8, mode)\n            _modeSelector := shl(48, mode)\n            _modePayload := shl(80, mode)\n        }\n    }\n\n    function encode(\n        CallType callType,\n        ExecType execType,\n        ExecModeSelector mode,\n        ExecModePayload payload\n    )\n        internal\n        pure\n        returns (ExecMode)\n    {\n        return ExecMode.wrap(\n            bytes32(\n                abi.encodePacked(\n                    callType, execType, bytes4(0), ExecModeSelector.unwrap(mode), payload\n                )\n            )\n        );\n    }\n\n    function encodeSimpleBatch() internal pure returns (ExecMode mode) {\n        mode =\n            encode(CALLTYPE_BATCH, EXECTYPE_DEFAULT, EXEC_MODE_DEFAULT, ExecModePayload.wrap(0x00));\n    }\n\n    function encodeSimpleSingle() internal pure returns (ExecMode mode) {\n        mode =\n            encode(CALLTYPE_SINGLE, EXECTYPE_DEFAULT, EXEC_MODE_DEFAULT, ExecModePayload.wrap(0x00));\n    }\n\n    function getCallType(ExecMode mode) internal pure returns (CallType calltype) {\n        assembly {\n            calltype := mode\n        }\n    }\n\n    function decodeBatch(bytes calldata callData)\n        internal\n        pure\n        returns (Execution[] calldata executionBatch)\n    {\n        /*\n         * Batch Call Calldata Layout\n         * Offset (in bytes)    | Length (in bytes) | Contents\n         * 0x0                  | 0x4               | bytes4 function selector\n        *  0x4                  | -                 |\n        abi.encode(IERC7579Execution.Execution[])\n         */\n        // solhint-disable-next-line no-inline-assembly\n        assembly (\"memory-safe\") {\n            let dataPointer := add(callData.offset, calldataload(callData.offset))\n\n            // Extract the ERC7579 Executions\n            executionBatch.offset := add(dataPointer, 32)\n            executionBatch.length := calldataload(dataPointer)\n        }\n    }\n\n    function encodeBatch(Execution[] memory executions)\n        internal\n        pure\n        returns (bytes memory callData)\n    {\n        callData = abi.encode(executions);\n    }\n\n    function decodeSingle(bytes calldata executionCalldata)\n        internal\n        pure\n        returns (address target, uint256 value, bytes calldata callData)\n    {\n        target = address(bytes20(executionCalldata[0:20]));\n        value = uint256(bytes32(executionCalldata[20:52]));\n        callData = executionCalldata[52:];\n    }\n\n    function encodeSingle(\n        address target,\n        uint256 value,\n        bytes memory callData\n    )\n        internal\n        pure\n        returns (bytes memory userOpCalldata)\n    {\n        userOpCalldata = abi.encodePacked(target, value, callData);\n    }\n\n    function doFallback2771Static(address fallbackHandler)\n        internal\n        view\n        returns (bool success, bytes memory result)\n    {\n        assembly {\n            function allocate(length) -> pos {\n                pos := mload(0x40)\n                mstore(0x40, add(pos, length))\n            }\n\n            let calldataPtr := allocate(calldatasize())\n            calldatacopy(calldataPtr, 0, calldatasize())\n\n            // The msg.sender address is shifted to the left by 12 bytes to remove the padding\n            // Then the address without padding is stored right after the calldata\n            let senderPtr := allocate(20)\n            mstore(senderPtr, shl(96, caller()))\n\n            // Add 20 bytes for the address appended add the end\n            success :=\n                staticcall(gas(), fallbackHandler, calldataPtr, add(calldatasize(), 20), 0, 0)\n\n            result := mload(0x40)\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }\n\n    function doFallback2771Call(address target)\n        internal\n        returns (bool success, bytes memory result)\n    {\n        assembly {\n            function allocate(length) -> pos {\n                pos := mload(0x40)\n                mstore(0x40, add(pos, length))\n            }\n\n            let calldataPtr := allocate(calldatasize())\n            calldatacopy(calldataPtr, 0, calldatasize())\n\n            // The msg.sender address is shifted to the left by 12 bytes to remove the padding\n            // Then the address without padding is stored right after the calldata\n            let senderPtr := allocate(20)\n            mstore(senderPtr, shl(96, caller()))\n\n            // Add 20 bytes for the address appended add the end\n            success := call(gas(), target, 0, calldataPtr, add(calldatasize(), 20), 0, 0)\n\n            result := mload(0x40)\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }\n}\n"},"node_modules/@rhinestone/modulekit/src/accounts/safe/interfaces/IERC7579Account.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.23 <0.9.0;\n\n// Types\nimport { CallType, ExecType, ModeCode } from \"../../common/lib/ModeLib.sol\";\n\n// Structs\nstruct Execution {\n    address target;\n    uint256 value;\n    bytes callData;\n}\n\ninterface IERC7579AccountEvents {\n    event ModuleInstalled(uint256 moduleTypeId, address module);\n    event ModuleUninstalled(uint256 moduleTypeId, address module);\n}\n\ninterface IERC7579AccountView {\n    /**\n     * @dev Returns the account id of the smart account\n     * @return accountImplementationId the account id of the smart account\n     * the accountId should be structured like so:\n     *        \"vendorname.accountname.semver\"\n     */\n    function accountId() external view returns (string memory accountImplementationId);\n\n    /**\n     * Function to check if the account supports a certain CallType or ExecType (see ModeLib.sol)\n     * @param encodedMode the encoded mode\n     */\n    function supportsExecutionMode(ModeCode encodedMode) external view returns (bool);\n\n    /**\n     * Function to check if the account supports installation of a certain module type Id\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     */\n    function supportsModule(uint256 moduleTypeId) external view returns (bool);\n}\n\ninterface IERC7579Account is IERC7579AccountEvents, IERC7579AccountView {\n    // Error thrown when an unsupported ModuleType is requested\n    error UnsupportedModuleType(uint256 moduleTypeId);\n    // Error thrown when an execution with an unsupported CallType was made\n    error UnsupportedCallType(CallType callType);\n    // Error thrown when an execution with an unsupported ExecType was made\n    error UnsupportedExecType(ExecType execType);\n    /**\n     * @dev Executes a transaction on behalf of the account.\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\n     * @dev Ensure adequate authorization control: i.e. onlyEntryPointOrSelf\n     *\n     * @dev MSA MUST implement this function signature.\n     * If a mode is requested that is not supported by the Account, it MUST revert\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\n     * @param executionCalldata The encoded execution call data\n     */\n\n    function execute(ModeCode mode, bytes calldata executionCalldata) external;\n\n    /**\n     * @dev Executes a transaction on behalf of the account.\n     *         This function is intended to be called by Executor Modules\n     * @dev Ensure adequate authorization control: i.e. onlyExecutorModule\n     *\n     * @dev MSA MUST implement this function signature.\n     * If a mode is requested that is not supported by the Account, it MUST revert\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\n     * @param executionCalldata The encoded execution call data\n     */\n    function executeFromExecutor(\n        ModeCode mode,\n        bytes calldata executionCalldata\n    )\n        external\n        returns (bytes[] memory returnData);\n\n    /**\n     * @dev ERC-1271 isValidSignature\n     *         This function is intended to be used to validate a smart account signature\n     * and may forward the call to a validator module\n     *\n     * @param hash The hash of the data that is signed\n     * @param data The data that is signed\n     */\n    function isValidSignature(bytes32 hash, bytes calldata data) external returns (bytes4);\n\n    /**\n     * @dev installs a Module of a certain type on the smart account\n     * @dev Implement Authorization control of your chosing\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     * @param module the module address\n     * @param initData arbitrary data that may be required on the module during `onInstall`\n     * initialization.\n     */\n    function installModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata initData\n    )\n        external;\n\n    /**\n     * @dev uninstalls a Module of a certain type on the smart account\n     * @dev Implement Authorization control of your chosing\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     * @param module the module address\n     * @param deInitData arbitrary data that may be required on the module during `onUninstall`\n     * de-initialization.\n     */\n    function uninstallModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata deInitData\n    )\n        external;\n\n    /**\n     * Function to check if the account has a certain module installed\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     *      Note: keep in mind that some contracts can be multiple module types at the same time. It\n     *            thus may be necessary to query multiple module types\n     * @param module the module address\n     * @param additionalContext additional context data that the smart account may interpret to\n     *                          identifiy conditions under which the module is installed.\n     *                          usually this is not necessary, but for some special hooks that\n     *                          are stored in mappings, this param might be needed\n     */\n    function isModuleInstalled(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata additionalContext\n    )\n        external\n        view\n        returns (bool);\n}\n"},"node_modules/@rhinestone/modulekit/src/accounts/safe/interfaces/ISafeOp.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.23 <0.9.0;\n\n// Types\nimport { PackedUserOperation } from \"account-abstraction/interfaces/PackedUserOperation.sol\";\n\nbytes32 constant SAFE_OP_TYPEHASH =\n    0xc03dfc11d8b10bf9cf703d558958c8c42777f785d998c62060d85a4f0ef6ea7f;\n\ninterface ISafeOp {\n    /**\n     * @notice The EIP-712 type-hash for a SafeOp, representing the structure of a User Operation\n     * for\n     * the Safe.\n     *  {address} safe - The address of the safe on which the operation is performed.\n     *  {uint256} nonce - A unique number associated with the user operation, preventing replay\n     * attacks\n     * by ensuring each operation is unique.\n     *  {bytes} initCode - The packed encoding of a factory address and its factory-specific data\n     * for\n     * creating a new Safe account.\n     *  {bytes} callData - The bytes representing the data of the function call to be executed.\n     *  {uint128} verificationGasLimit - The maximum amount of gas allowed for the verification\n     * process.\n     *  {uint128} callGasLimit - The maximum amount of gas allowed for executing the function call.\n     *  {uint256} preVerificationGas - The amount of gas allocated for pre-verification steps before\n     * executing the main operation.\n     *  {uint128} maxPriorityFeePerGas - The maximum priority fee per gas that the user is willing\n     * to\n     * pay for the transaction.\n     *  {uint128} maxFeePerGas - The maximum fee per gas that the user is willing to pay for the\n     * transaction.\n     *  {bytes} paymasterAndData - The packed encoding of a paymaster address and its\n     * paymaster-specific\n     * data for sponsoring the user operation.\n     *  {uint48} validAfter - A timestamp representing from when the user operation is valid.\n     *  {uint48} validUntil - A timestamp representing until when the user operation is valid, or 0\n     * to\n     * indicated \"forever\".\n     *  {address} entryPoint - The address of the entry point that will execute the user operation.\n     * @dev When validating the user operation, the signature timestamps are pre-pended to the\n     * signature\n     * bytes. Equal to:\n     * keccak256(\n     *     \"SafeOp(address safe,uint256 nonce,bytes initCode,bytes callData,uint128\n     * verificationGasLimit,uint128 callGasLimit,uint256 preVerificationGas,uint128\n     * maxPriorityFeePerGas,uint128 maxFeePerGas,bytes paymasterAndData,uint48 validAfter,uint48\n     * validUntil,address entryPoint)\"\n     * ) = 0xc03dfc11d8b10bf9cf703d558958c8c42777f785d998c62060d85a4f0ef6ea7f\n     */\n    struct EncodedSafeOpStruct {\n        bytes32 typeHash;\n        address safe;\n        uint256 nonce;\n        bytes32 initCodeHash;\n        bytes32 callDataHash;\n        uint128 verificationGasLimit;\n        uint128 callGasLimit;\n        uint256 preVerificationGas;\n        uint128 maxPriorityFeePerGas;\n        uint128 maxFeePerGas;\n        bytes32 paymasterAndDataHash;\n        uint48 validAfter;\n        uint48 validUntil;\n        address entryPoint;\n    }\n\n    function domainSeparator() external view returns (bytes32);\n\n    function getSafeOp(\n        PackedUserOperation calldata userOp,\n        address entryPoint\n    )\n        external\n        view\n        returns (\n            bytes memory operationData,\n            uint48 validAfter,\n            uint48 validUntil,\n            bytes calldata signatures\n        );\n}\n"},"node_modules/@rhinestone/modulekit/src/accounts/safe/types/DataTypes.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.23 <0.9.0;\n\n// Interfaces\nimport { IERC7484 } from \"../interfaces/IERC7484.sol\";\n\n// Types\nimport { CallType } from \"../../common/lib/ModeLib.sol\";\n\nstruct FallbackHandler {\n    address handler;\n    CallType calltype;\n}\n\nenum HookType {\n    GLOBAL,\n    SIG\n}\n\nstruct ModuleInit {\n    address module;\n    bytes initData;\n}\n\nstruct RegistryInit {\n    IERC7484 registry;\n    address[] attesters;\n    uint8 threshold;\n}\n"},"node_modules/forge-std/src/interfaces/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceID The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    /// uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    /// `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/interfaces/IPaymaster.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./PackedUserOperation.sol\";\n\n/**\n * The interface exposed by a paymaster contract, who agrees to pay the gas for user's operations.\n * A paymaster must hold a stake to cover the required entrypoint stake and also the gas for the transaction.\n */\ninterface IPaymaster {\n    enum PostOpMode {\n        // User op succeeded.\n        opSucceeded,\n        // User op reverted. Still has to pay for gas.\n        opReverted,\n        // Only used internally in the EntryPoint (cleanup after postOp reverts). Never calling paymaster with this value\n        postOpReverted\n    }\n\n    /**\n     * Payment validation: check if paymaster agrees to pay.\n     * Must verify sender is the entryPoint.\n     * Revert to reject this request.\n     * Note that bundlers will reject this method if it changes the state, unless the paymaster is trusted (whitelisted).\n     * The paymaster pre-pays using its deposit, and receive back a refund after the postOp method returns.\n     * @param userOp          - The user operation.\n     * @param userOpHash      - Hash of the user's request data.\n     * @param maxCost         - The maximum cost of this transaction (based on maximum gas and gas price from userOp).\n     * @return context        - Value to send to a postOp. Zero length to signify postOp is not required.\n     * @return validationData - Signature and time-range of this operation, encoded the same as the return\n     *                          value of validateUserOperation.\n     *                          <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\n     *                                                    other values are invalid for paymaster.\n     *                          <6-byte> validUntil - last timestamp this operation is valid. 0 for \"indefinite\"\n     *                          <6-byte> validAfter - first timestamp this operation is valid\n     *                          Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    function validatePaymasterUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 maxCost\n    ) external returns (bytes memory context, uint256 validationData);\n\n    /**\n     * Post-operation handler.\n     * Must verify sender is the entryPoint.\n     * @param mode          - Enum with the following options:\n     *                        opSucceeded - User operation succeeded.\n     *                        opReverted  - User op reverted. The paymaster still has to pay for gas.\n     *                        postOpReverted - never passed in a call to postOp().\n     * @param context       - The context value returned by validatePaymasterUserOp\n     * @param actualGasCost - Actual gas used so far (without this postOp call).\n     * @param actualUserOpFeePerGas - the gas price this UserOp pays. This value is based on the UserOp's maxFeePerGas\n     *                        and maxPriorityFee (and basefee)\n     *                        It is not the same as tx.gasprice, which is what the bundler pays.\n     */\n    function postOp(\n        PostOpMode mode,\n        bytes calldata context,\n        uint256 actualGasCost,\n        uint256 actualUserOpFeePerGas\n    ) external;\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/utils/Exec.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity ^0.8.23;\n\n// solhint-disable no-inline-assembly\n\n/**\n * Utility functions helpful when making different kinds of contract calls in Solidity.\n */\nlibrary Exec {\n\n    function call(\n        address to,\n        uint256 value,\n        bytes memory data,\n        uint256 txGas\n    ) internal returns (bool success) {\n        assembly (\"memory-safe\") {\n            success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\n        }\n    }\n\n    function staticcall(\n        address to,\n        bytes memory data,\n        uint256 txGas\n    ) internal view returns (bool success) {\n        assembly (\"memory-safe\") {\n            success := staticcall(txGas, to, add(data, 0x20), mload(data), 0, 0)\n        }\n    }\n\n    function delegateCall(\n        address to,\n        bytes memory data,\n        uint256 txGas\n    ) internal returns (bool success) {\n        assembly (\"memory-safe\") {\n            success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\n        }\n    }\n\n    // get returned data from last call or calldelegate\n    function getReturnData(uint256 maxLen) internal pure returns (bytes memory returnData) {\n        assembly (\"memory-safe\") {\n            let len := returndatasize()\n            if gt(len, maxLen) {\n                len := maxLen\n            }\n            let ptr := mload(0x40)\n            mstore(0x40, add(ptr, add(len, 0x20)))\n            mstore(ptr, len)\n            returndatacopy(add(ptr, 0x20), 0, len)\n            returnData := ptr\n        }\n    }\n\n    // revert with explicit byte array (probably reverted info from call)\n    function revertWithData(bytes memory returnData) internal pure {\n        assembly (\"memory-safe\") {\n            revert(add(returnData, 32), mload(returnData))\n        }\n    }\n\n    function callAndRevert(address to, bytes memory data, uint256 maxLen) internal {\n        bool success = call(to,0,data,gasleft());\n        if (!success) {\n            revertWithData(getReturnData(maxLen));\n        }\n    }\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/core/StakeManager.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.23;\n\nimport \"../interfaces/IStakeManager.sol\";\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable not-rely-on-time */\n\n/**\n * Manage deposits and stakes.\n * Deposit is just a balance used to pay for UserOperations (either by a paymaster or an account).\n * Stake is value locked for at least \"unstakeDelay\" by a paymaster.\n */\nabstract contract StakeManager is IStakeManager {\n    /// maps paymaster to their deposits and stakes\n    mapping(address => DepositInfo) public deposits;\n\n    /// @inheritdoc IStakeManager\n    function getDepositInfo(\n        address account\n    ) public view returns (DepositInfo memory info) {\n        return deposits[account];\n    }\n\n    /**\n     * Internal method to return just the stake info.\n     * @param addr - The account to query.\n     */\n    function _getStakeInfo(\n        address addr\n    ) internal view returns (StakeInfo memory info) {\n        DepositInfo storage depositInfo = deposits[addr];\n        info.stake = depositInfo.stake;\n        info.unstakeDelaySec = depositInfo.unstakeDelaySec;\n    }\n\n    /// @inheritdoc IStakeManager\n    function balanceOf(address account) public view returns (uint256) {\n        return deposits[account].deposit;\n    }\n\n    receive() external payable {\n        depositTo(msg.sender);\n    }\n\n    /**\n     * Increments an account's deposit.\n     * @param account - The account to increment.\n     * @param amount  - The amount to increment by.\n     * @return the updated deposit of this account\n     */\n    function _incrementDeposit(address account, uint256 amount) internal returns (uint256) {\n        DepositInfo storage info = deposits[account];\n        uint256 newAmount = info.deposit + amount;\n        info.deposit = newAmount;\n        return newAmount;\n    }\n\n    /**\n     * Add to the deposit of the given account.\n     * @param account - The account to add to.\n     */\n    function depositTo(address account) public virtual payable {\n        uint256 newDeposit = _incrementDeposit(account, msg.value);\n        emit Deposited(account, newDeposit);\n    }\n\n    /**\n     * Add to the account's stake - amount and delay\n     * any pending unstake is first cancelled.\n     * @param unstakeDelaySec The new lock duration before the deposit can be withdrawn.\n     */\n    function addStake(uint32 unstakeDelaySec) public payable {\n        DepositInfo storage info = deposits[msg.sender];\n        require(unstakeDelaySec > 0, \"must specify unstake delay\");\n        require(\n            unstakeDelaySec >= info.unstakeDelaySec,\n            \"cannot decrease unstake time\"\n        );\n        uint256 stake = info.stake + msg.value;\n        require(stake > 0, \"no stake specified\");\n        require(stake <= type(uint112).max, \"stake overflow\");\n        deposits[msg.sender] = DepositInfo(\n            info.deposit,\n            true,\n            uint112(stake),\n            unstakeDelaySec,\n            0\n        );\n        emit StakeLocked(msg.sender, stake, unstakeDelaySec);\n    }\n\n    /**\n     * Attempt to unlock the stake.\n     * The value can be withdrawn (using withdrawStake) after the unstake delay.\n     */\n    function unlockStake() external {\n        DepositInfo storage info = deposits[msg.sender];\n        require(info.unstakeDelaySec != 0, \"not staked\");\n        require(info.staked, \"already unstaking\");\n        uint48 withdrawTime = uint48(block.timestamp) + info.unstakeDelaySec;\n        info.withdrawTime = withdrawTime;\n        info.staked = false;\n        emit StakeUnlocked(msg.sender, withdrawTime);\n    }\n\n    /**\n     * Withdraw from the (unlocked) stake.\n     * Must first call unlockStake and wait for the unstakeDelay to pass.\n     * @param withdrawAddress - The address to send withdrawn value.\n     */\n    function withdrawStake(address payable withdrawAddress) external {\n        DepositInfo storage info = deposits[msg.sender];\n        uint256 stake = info.stake;\n        require(stake > 0, \"No stake to withdraw\");\n        require(info.withdrawTime > 0, \"must call unlockStake() first\");\n        require(\n            info.withdrawTime <= block.timestamp,\n            \"Stake withdrawal is not due\"\n        );\n        info.unstakeDelaySec = 0;\n        info.withdrawTime = 0;\n        info.stake = 0;\n        emit StakeWithdrawn(msg.sender, withdrawAddress, stake);\n        (bool success,) = withdrawAddress.call{value: stake}(\"\");\n        require(success, \"failed to withdraw stake\");\n    }\n\n    /**\n     * Withdraw from the deposit.\n     * @param withdrawAddress - The address to send withdrawn value.\n     * @param withdrawAmount  - The amount to withdraw.\n     */\n    function withdrawTo(\n        address payable withdrawAddress,\n        uint256 withdrawAmount\n    ) external {\n        DepositInfo storage info = deposits[msg.sender];\n        require(withdrawAmount <= info.deposit, \"Withdraw amount too large\");\n        info.deposit = info.deposit - withdrawAmount;\n        emit Withdrawn(msg.sender, withdrawAddress, withdrawAmount);\n        (bool success,) = withdrawAddress.call{value: withdrawAmount}(\"\");\n        require(success, \"failed to withdraw\");\n    }\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/core/SenderCreator.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.23;\n\n/**\n * Helper contract for EntryPoint, to call userOp.initCode from a \"neutral\" address,\n * which is explicitly not the entryPoint itself.\n */\ncontract SenderCreator {\n    /**\n     * Call the \"initCode\" factory to create and return the sender account address.\n     * @param initCode - The initCode value from a UserOp. contains 20 bytes of factory address,\n     *                   followed by calldata.\n     * @return sender  - The returned address of the created account, or zero address on failure.\n     */\n    function createSender(\n        bytes calldata initCode\n    ) external returns (address sender) {\n        address factory = address(bytes20(initCode[0:20]));\n        bytes memory initCallData = initCode[20:];\n        bool success;\n        /* solhint-disable no-inline-assembly */\n        assembly (\"memory-safe\") {\n            success := call(\n                gas(),\n                factory,\n                0,\n                add(initCallData, 0x20),\n                mload(initCallData),\n                0,\n                32\n            )\n            sender := mload(0)\n        }\n        if (!success) {\n            sender = address(0);\n        }\n    }\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/core/NonceManager.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.23;\n\nimport \"../interfaces/INonceManager.sol\";\n\n/**\n * nonce management functionality\n */\nabstract contract NonceManager is INonceManager {\n\n    /**\n     * The next valid sequence number for a given nonce key.\n     */\n    mapping(address => mapping(uint192 => uint256)) public nonceSequenceNumber;\n\n    /// @inheritdoc INonceManager\n    function getNonce(address sender, uint192 key)\n    public view override returns (uint256 nonce) {\n        return nonceSequenceNumber[sender][key] | (uint256(key) << 64);\n    }\n\n    // allow an account to manually increment its own nonce.\n    // (mainly so that during construction nonce can be made non-zero,\n    // to \"absorb\" the gas cost of first nonce increment to 1st transaction (construction),\n    // not to 2nd transaction)\n    function incrementNonce(uint192 key) public override {\n        nonceSequenceNumber[msg.sender][key]++;\n    }\n\n    /**\n     * validate nonce uniqueness for this account.\n     * called just after validateUserOp()\n     * @return true if the nonce was incremented successfully.\n     *         false if the current nonce doesn't match the given one.\n     */\n    function _validateAndUpdateNonce(address sender, uint256 nonce) internal returns (bool) {\n\n        uint192 key = uint192(nonce >> 64);\n        uint64 seq = uint64(nonce);\n        return nonceSequenceNumber[sender][key]++ == seq;\n    }\n\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/core/GasDebug.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.23;\n\ncontract GasDebug {\n    // Phase 0: account creation\n    // Phase 1: validation\n    // Phase 2: execution\n    mapping(address account => mapping(uint256 phase => uint256 gas)) gasConsumed;\n\n    function setGasConsumed(address account, uint256 phase, uint256 gas) internal {\n        gasConsumed[account][phase] = gas;\n    }\n\n    function getGasConsumed(address account, uint256 phase) public view returns (uint256) {\n        return gasConsumed[account][phase];\n    }\n}\n"},"node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"},"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"},"node_modules/@rhinestone/modulekit/src/accounts/kernel/types/Types.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.23 <0.9.0;\n\n// Custom type for improved developer experience\ntype ExecMode is bytes32;\n\ntype CallType is bytes1;\n\ntype ExecType is bytes1;\n\ntype ExecModeSelector is bytes4;\n\ntype ExecModePayload is bytes22;\n\nusing { eqModeSelector as == } for ExecModeSelector global;\nusing { eqCallType as == } for CallType global;\nusing { notEqCallType as != } for CallType global;\nusing { eqExecType as == } for ExecType global;\n\nfunction eqCallType(CallType a, CallType b) pure returns (bool) {\n    return CallType.unwrap(a) == CallType.unwrap(b);\n}\n\nfunction notEqCallType(CallType a, CallType b) pure returns (bool) {\n    return CallType.unwrap(a) != CallType.unwrap(b);\n}\n\nfunction eqExecType(ExecType a, ExecType b) pure returns (bool) {\n    return ExecType.unwrap(a) == ExecType.unwrap(b);\n}\n\nfunction eqModeSelector(ExecModeSelector a, ExecModeSelector b) pure returns (bool) {\n    return ExecModeSelector.unwrap(a) == ExecModeSelector.unwrap(b);\n}\n\ntype ValidationMode is bytes1;\n\ntype ValidationId is bytes21;\n\ntype ValidationType is bytes1;\n\ntype PermissionId is bytes4;\n\ntype PolicyData is bytes22; // 2bytes for flag on skip, 20 bytes for validator address\n\ntype PassFlag is bytes2;\n\nusing { vModeEqual as == } for ValidationMode global;\nusing { vTypeEqual as == } for ValidationType global;\nusing { vIdentifierEqual as == } for ValidationId global;\nusing { vModeNotEqual as != } for ValidationMode global;\nusing { vTypeNotEqual as != } for ValidationType global;\nusing { vIdentifierNotEqual as != } for ValidationId global;\n\n// nonce = uint192(key) + nonce\n// key = mode + (vtype + validationDataWithoutType) + 2bytes parallelNonceKey\n// key = 0x00 + 0x00 + 0x000 .. 00 + 0x0000\n// key = 0x00 + 0x01 + 0x1234...ff + 0x0000\n// key = 0x00 + 0x02 + ( ) + 0x000\n\nfunction vModeEqual(ValidationMode a, ValidationMode b) pure returns (bool) {\n    return ValidationMode.unwrap(a) == ValidationMode.unwrap(b);\n}\n\nfunction vModeNotEqual(ValidationMode a, ValidationMode b) pure returns (bool) {\n    return ValidationMode.unwrap(a) != ValidationMode.unwrap(b);\n}\n\nfunction vTypeEqual(ValidationType a, ValidationType b) pure returns (bool) {\n    return ValidationType.unwrap(a) == ValidationType.unwrap(b);\n}\n\nfunction vTypeNotEqual(ValidationType a, ValidationType b) pure returns (bool) {\n    return ValidationType.unwrap(a) != ValidationType.unwrap(b);\n}\n\nfunction vIdentifierEqual(ValidationId a, ValidationId b) pure returns (bool) {\n    return ValidationId.unwrap(a) == ValidationId.unwrap(b);\n}\n\nfunction vIdentifierNotEqual(ValidationId a, ValidationId b) pure returns (bool) {\n    return ValidationId.unwrap(a) != ValidationId.unwrap(b);\n}\n\ntype ValidationData is uint256;\n\ntype ValidAfter is uint48;\n\ntype ValidUntil is uint48;\n\nfunction getValidationResult(ValidationData validationData) pure returns (address result) {\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n        result := validationData\n    }\n}\n\nfunction packValidationData(ValidAfter validAfter, ValidUntil validUntil) pure returns (uint256) {\n    return uint256(ValidAfter.unwrap(validAfter)) << 208\n        | uint256(ValidUntil.unwrap(validUntil)) << 160;\n}\n\nfunction parseValidationData(uint256 validationData)\n    pure\n    returns (ValidAfter validAfter, ValidUntil validUntil, address result)\n{\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n        result := validationData\n        validUntil := and(shr(160, validationData), 0xffffffffffff)\n        switch iszero(validUntil)\n        case 1 { validUntil := 0xffffffffffff }\n        validAfter := shr(208, validationData)\n    }\n}\n"},"node_modules/@rhinestone/modulekit/src/accounts/kernel/types/Constants.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.23 <0.9.0;\n\nimport { CallType, ExecType, ExecModeSelector } from \"./Types.sol\";\nimport { PassFlag, ValidationMode, ValidationType } from \"./Types.sol\";\nimport { ValidationData } from \"./Types.sol\";\n\n// --- ERC7579 calltypes ---\n// Default CallType\nCallType constant CALLTYPE_SINGLE = CallType.wrap(0x00);\n// Batched CallType\nCallType constant CALLTYPE_BATCH = CallType.wrap(0x01);\nCallType constant CALLTYPE_STATIC = CallType.wrap(0xFE);\n// @dev Implementing delegatecall is OPTIONAL!\n// implement delegatecall with extreme care.\nCallType constant CALLTYPE_DELEGATECALL = CallType.wrap(0xFF);\n\n// --- ERC7579 exectypes ---\n// @dev default behavior is to revert on failure\n// To allow very simple accounts to use mode encoding, the default behavior is to revert on failure\n// Since this is value 0x00, no additional encoding is required for simple accounts\nExecType constant EXECTYPE_DEFAULT = ExecType.wrap(0x00);\n// @dev account may elect to change execution behavior. For example \"try exec\" / \"allow fail\"\nExecType constant EXECTYPE_TRY = ExecType.wrap(0x01);\n\n// --- ERC7579 mode selector ---\nExecModeSelector constant EXEC_MODE_DEFAULT = ExecModeSelector.wrap(bytes4(0x00000000));\n\n// --- Kernel permission skip flags ---\nPassFlag constant SKIP_USEROP = PassFlag.wrap(0x0001);\nPassFlag constant SKIP_SIGNATURE = PassFlag.wrap(0x0002);\n\n// --- Kernel validation modes ---\nValidationMode constant VALIDATION_MODE_DEFAULT = ValidationMode.wrap(0x00);\nValidationMode constant VALIDATION_MODE_ENABLE = ValidationMode.wrap(0x01);\nValidationMode constant VALIDATION_MODE_INSTALL = ValidationMode.wrap(0x02);\n\n// --- Kernel validation types ---\nValidationType constant VALIDATION_TYPE_ROOT = ValidationType.wrap(0x00);\nValidationType constant VALIDATION_TYPE_VALIDATOR = ValidationType.wrap(0x01);\nValidationType constant VALIDATION_TYPE_PERMISSION = ValidationType.wrap(0x02);\n\n// --- storage slots ---\n// bytes32(uint256(keccak256('kernel.v3.selector')) - 1)\nbytes32 constant SELECTOR_MANAGER_STORAGE_SLOT =\n    0x7c341349a4360fdd5d5bc07e69f325dc6aaea3eb018b3e0ea7e53cc0bb0d6f3b;\n// bytes32(uint256(keccak256('kernel.v3.executor')) - 1)\nbytes32 constant EXECUTOR_MANAGER_STORAGE_SLOT =\n    0x1bbee3173dbdc223633258c9f337a0fff8115f206d302bea0ed3eac003b68b86;\n// bytes32(uint256(keccak256('kernel.v3.hook')) - 1)\nbytes32 constant HOOK_MANAGER_STORAGE_SLOT =\n    0x4605d5f70bb605094b2e761eccdc27bed9a362d8612792676bf3fb9b12832ffc;\n// bytes32(uint256(keccak256('kernel.v3.validation')) - 1)\nbytes32 constant VALIDATION_MANAGER_STORAGE_SLOT =\n    0x7bcaa2ced2a71450ed5a9a1b4848e8e5206dbc3f06011e595f7f55428cc6f84f;\nbytes32 constant ERC1967_IMPLEMENTATION_SLOT =\n    0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n// --- Kernel validation nonce incremental size limit ---\nuint32 constant MAX_NONCE_INCREMENT_SIZE = 10;\n\n// -- EIP712 type hash ---\nbytes32 constant ENABLE_TYPE_HASH =\n    0xb17ab1224aca0d4255ef8161acaf2ac121b8faa32a4b2258c912cc5f8308c505;\nbytes32 constant KERNEL_WRAPPER_TYPE_HASH =\n    0x1547321c374afde8a591d972a084b071c594c275e36724931ff96c25f2999c83;\n\n// --- ERC constants ---\n// ERC4337 constants\nuint256 constant SIG_VALIDATION_FAILED_UINT = 1;\nuint256 constant SIG_VALIDATION_SUCCESS_UINT = 0;\nValidationData constant SIG_VALIDATION_FAILED = ValidationData.wrap(SIG_VALIDATION_FAILED_UINT);\n\n// ERC-1271 constants\nbytes4 constant ERC1271_MAGICVALUE = 0x1626ba7e;\nbytes4 constant ERC1271_INVALID = 0xffffffff;\n\nuint256 constant MODULE_TYPE_VALIDATOR = 1;\nuint256 constant MODULE_TYPE_EXECUTOR = 2;\nuint256 constant MODULE_TYPE_FALLBACK = 3;\nuint256 constant MODULE_TYPE_HOOK = 4;\nuint256 constant MODULE_TYPE_POLICY = 5;\nuint256 constant MODULE_TYPE_SIGNER = 6;\n"},"node_modules/@rhinestone/modulekit/src/accounts/kernel/types/Structs.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.23 <0.9.0;\n\nstruct Execution {\n    address target;\n    uint256 value;\n    bytes callData;\n}\n"},"node_modules/@rhinestone/modulekit/src/accounts/safe/interfaces/IERC7484.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.23 <0.9.0;\n\ninterface IERC7484 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*          Check with Registry internal attesters            */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function check(address module) external view;\n\n    function checkForAccount(address smartAccount, address module) external view;\n\n    function check(address module, uint256 moduleType) external view;\n\n    function checkForAccount(\n        address smartAccount,\n        address module,\n        uint256 moduleType\n    )\n        external\n        view;\n\n    /**\n     * Allows Smart Accounts - the end users of the registry - to appoint\n     * one or many attesters as trusted.\n     * @dev this function reverts, if address(0), or duplicates are provided in attesters[]\n     *\n     * @param threshold The minimum number of attestations required for a module\n     *                  to be considered secure.\n     * @param attesters The addresses of the attesters to be trusted.\n     */\n    function trustAttesters(uint8 threshold, address[] calldata attesters) external;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              Check with external attester(s)               */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function check(address module, address[] calldata attesters, uint256 threshold) external view;\n\n    function check(\n        address module,\n        uint256 moduleType,\n        address[] calldata attesters,\n        uint256 threshold\n    )\n        external\n        view;\n}\n"},"node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"}},"settings":{"remappings":["@rhinestone/=node_modules/@rhinestone/","sentinellist/=node_modules/@rhinestone/sentinellist/src/","erc4337-validation/=node_modules/@rhinestone/erc4337-validation/src/","modulekit/=node_modules/@rhinestone/modulekit/src/","checknsignatures/=node_modules/@rhinestone/checknsignatures/src/","flatbytes/=node_modules/@rhinestone/flatbytes/src/","@ERC4337/=node_modules/@ERC4337/","account-abstraction/=node_modules/@ERC4337/account-abstraction/contracts/","account-abstraction-v0.6/=node_modules/@ERC4337/account-abstraction-v0.6/contracts/","@openzeppelin/=node_modules/@openzeppelin/","@safe-global/=node_modules/@safe-global/","ds-test/=node_modules/ds-test/src/","forge-std/=node_modules/forge-std/src/","solady/=node_modules/solady/src/","solarray/=node_modules/solarray/src/","@prb/math/=node_modules/@prb/math/src/","solmate/=node_modules/solmate/src/","ExcessivelySafeCall/=node_modules/excessively-safe-call/src/","@webauthn/=node_modules/webauthn-sol/src/","@erc7579/enumerablemap4337/=node_modules/@erc7579/enumerablemap4337/src/","FreshCryptoLib/=node_modules/FreshCryptoLib/solidity/src/","node_modules/webauthn-sol/src/:openzeppelin-contracts/=node_modules/@openzeppelin/","@gnosis.pm/=node_modules/@gnosis.pm/","excessively-safe-call/=node_modules/excessively-safe-call/","hardhat-deploy/=node_modules/hardhat-deploy/","hardhat/=node_modules/hardhat/","webauthn-sol/=node_modules/webauthn-sol/"],"optimizer":{"enabled":false,"runs":200},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode.object","evm.bytecode.sourceMap","evm.bytecode.linkReferences","evm.deployedBytecode.object","evm.deployedBytecode.sourceMap","evm.deployedBytecode.linkReferences","evm.deployedBytecode.immutableReferences","evm.methodIdentifiers","metadata"]}},"evmVersion":"cancun","viaIR":false,"libraries":{}}}
